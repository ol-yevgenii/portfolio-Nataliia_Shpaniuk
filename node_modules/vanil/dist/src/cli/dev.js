"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLiveReloadUrl = exports.notifyChange = exports.dev = exports.triggerTransformAll = void 0;
const chokidar_1 = require("chokidar");
const path_1 = require("path");
const colors = __importStar(require("kleur/colors"));
const WebSocket = __importStar(require("ws"));
const preview_1 = require("./preview");
const config_1 = require("../core/config");
const orchestrate_1 = require("../core/orchestrate");
const folders_1 = require("../core/io/folders");
const debounce_1 = require("../core/time/debounce");
const copyPublicToDist_1 = require("../core/hook/core/copyPublicToDist");
const cache_1 = require("../core/transform/cache");
const publicFolderChangeCopyDebounceMs = 25;
const fileChangeDebounceMs = 30;
const triggerTransformAll = async (serverConfig, config, devWebSocketServer) => await (0, orchestrate_1.orchestrateTransformAll)({
    config,
    command: 'dev',
    mode: (0, config_1.getExecutionMode)(),
    // register in context for onDevServerStart hooks to apply
    devServer: serverConfig.server,
    expressApp: serverConfig.app,
    devWebSocketServer,
});
exports.triggerTransformAll = triggerTransformAll;
/**
 * dev HTTP server that watches for src folder changes and
 * informs connected webrowsers for when rebuilds of pages have happened
 */
const dev = async (config) => {
    var _a, _b;
    // start preview HTTP server
    console.log('config', config.devOptions);
    const serverConfig = await (0, preview_1.preview)(config, false);
    // create the /livereload endpoint via ws://
    const devWebSocketServer = new WebSocket.Server({
        server: serverConfig.server,
        host: (_a = config.devOptions) === null || _a === void 0 ? void 0 : _a.hostname,
        path: '/livereload',
    });
    // listen for HTTP and WS connections
    serverConfig.server.listen((_b = config.devOptions) === null || _b === void 0 ? void 0 : _b.port, () => (0, preview_1.printServerRunning)('DevServer', config));
    let context = await (0, exports.triggerTransformAll)(serverConfig, config, devWebSocketServer);
    // [hmr] notify initial (initial transform, for connected clients)
    (0, exports.notifyChange)(devWebSocketServer, context);
    // === watching for changes
    const projectDir = (0, path_1.resolve)(__dirname, '../../', config.projectRoot);
    const projectDistDir = (0, path_1.resolve)(projectDir, config.dist);
    const projectNodeModulesDir = (0, path_1.resolve)(projectDir, 'node_modules');
    // TODO: add excluded dirs to project config devServer as a flag
    const excludedFolders = [projectDistDir, projectNodeModulesDir];
    const isInExcludedFolder = (path) => {
        let isExcluded = false;
        excludedFolders.forEach((excludedFolder) => {
            if (path.indexOf(excludedFolder) > -1) {
                isExcluded = true;
            }
        });
        return isExcluded;
    };
    const handleFileChange = async (path) => {
        if (context.fileDependenciesToRestartOn.indexOf(path) > -1) {
            console.log(colors.yellow(`> Re-transform all: ${(0, folders_1.toProjectRootRelativePath)(path, config)} changed...`));
            context = await (0, exports.triggerTransformAll)(serverConfig, config, devWebSocketServer);
            (0, exports.notifyChange)(devWebSocketServer, context);
            return;
        }
        // list of .astro files to retransform
        const astroTemplatesToTransform = [];
        // pre-process fileDependencies:  transient .astro component -> .astro page dependencies
        if (context.fileDependencies[path]) {
            const dependentAstroPages = context.fileDependencies[path];
            dependentAstroPages.forEach((astroPageCandidate, index) => {
                // .astro component dependent to .astro component -> resolve top level .astro page template deps
                if (!(0, folders_1.isAstroPageTemplate)(astroPageCandidate, config) && astroPageCandidate.endsWith('.astro')) {
                    // actual astro page dependencies
                    const astroPageDeps = context.fileDependencies[astroPageCandidate] || [];
                    // replace transient dependency
                    dependentAstroPages.splice(index, astroPageDeps.length, ...astroPageDeps);
                }
            });
        }
        Object.keys(context.fileDependencies).forEach((depFilePath) => {
            // some module imports doesn't come with a file extension and it's
            // good enough to not resolve those with expensive ops but just assume
            // we might need to rebuild stochastically valid dependencies
            if (path.startsWith(depFilePath)) {
                context.fileDependencies[depFilePath].forEach((astroFile) => {
                    if ((0, folders_1.isAstroPageTemplate)(astroFile, config) && astroTemplatesToTransform.indexOf(astroFile) === -1) {
                        // invalidate the codeCache
                        (0, cache_1.invalidateCache)(context);
                        // adds the .astro file to the list of .astro files
                        // to re-transform when the file changed is an (in)direct
                        // dependency of it
                        astroTemplatesToTransform.push(astroFile);
                    }
                });
            }
        });
        // if the file changed is an .astro template file and not yet part of the list
        // of .astro templates to retransform, add
        if (path.endsWith('.astro') &&
            (0, folders_1.isAstroPageTemplate)(path, config) &&
            astroTemplatesToTransform.indexOf(path) === -1) {
            astroTemplatesToTransform.push(path);
        }
        else if (path.endsWith('.astro')) {
            // .astro component case; clear component cache
            context.codeCache = {};
        }
        // walk thru all .astro templates that depend on the files changed
        // and retransform them
        for (let i = 0; i < astroTemplatesToTransform.length; i++) {
            // incrementally compile with file changed hint
            context = await (0, orchestrate_1.orchestrateTransformSingle)({
                ...context,
                config,
                command: 'dev',
                mode: (0, config_1.getExecutionMode)(),
                path: astroTemplatesToTransform[i],
                // in dev mode, dynamic routes pass multiple times
                // and the context is kept across transform runs,
                // whereas building permutations only happens when
                // no materialized path is set yet
                //materializedPath: undefined
            });
        }
        // [hmr] notify on change
        (0, exports.notifyChange)(devWebSocketServer, context);
    };
    /** triggers file change handling, but debounced to we don't get too many re-transforms  */
    const handleFileChangeDebounced = (0, debounce_1.debounce)(handleFileChange, fileChangeDebounceMs);
    /** copies over public/** to dist/** on file change in public dir */
    const handlePublicDirFileOperationDebounced = (0, debounce_1.debounce)((path) => {
        if (path.startsWith((0, folders_1.getPublicFolder)(context.config))) {
            (0, copyPublicToDist_1.copyPublicToDist)(context);
        }
    }, publicFolderChangeCopyDebounceMs /* ms, to prevent triggering the copy too many times */);
    // watch for file changes
    (0, chokidar_1.watch)(`${projectDir}/**`).on('all', async (eventName, path) => {
        // public dir file operation happened, copy files to dist
        handlePublicDirFileOperationDebounced(path);
        // only watch out for changes and included directories
        if (eventName !== 'change' || isInExcludedFolder(path))
            return;
        handleFileChangeDebounced(path);
    });
};
exports.dev = dev;
/** inform all connected websocket clients about a change */
const notifyChange = (devWebSocketServer, context) => {
    devWebSocketServer.clients.forEach((ws) => {
        const materializedHtmlFilePaths = context.materializedHtmlFilePaths[context.path];
        if (!materializedHtmlFilePaths)
            return;
        ws.send(JSON.stringify({
            operation: 'transform',
            paths: materializedHtmlFilePaths.map((matHtmlFilePath) => (0, folders_1.toDistFolderRelativePath)(matHtmlFilePath, context.config)),
        }));
    });
};
exports.notifyChange = notifyChange;
const getLiveReloadUrl = (config) => { var _a, _b; return `ws://${(_a = config.devOptions) === null || _a === void 0 ? void 0 : _a.hostname}:${(_b = config.devOptions) === null || _b === void 0 ? void 0 : _b.port}/livereload`; };
exports.getLiveReloadUrl = getLiveReloadUrl;
