"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = void 0;
const colors = __importStar(require("kleur/colors"));
const yargs_parser_1 = __importDefault(require("yargs-parser"));
const path_1 = require("path");
const dev_1 = require("./dev");
const build_1 = require("./build");
const check_1 = require("./check");
const preview_1 = require("./preview");
const config_1 = require("../core/config");
const file_1 = require("../core/io/file");
const clean_1 = require("./clean");
const init_1 = require("./init");
const dotenv = require('dotenv');
/** Determine which action the user requested */
const resolveArgs = (flags) => {
    const options = {
        projectRoot: typeof flags.projectRoot === 'string' ? flags.projectRoot : undefined,
        site: typeof flags.site === 'string' ? flags.site : undefined,
        sitemap: typeof flags.sitemap === 'boolean' ? flags.sitemap : undefined,
        port: typeof flags.port === 'number' ? flags.port : undefined,
        hostname: typeof flags.hostname === 'string' ? flags.hostname : undefined,
        config: typeof flags.config === 'string' ? flags.config : undefined,
        dist: typeof flags.dist === 'string' ? flags.dist : undefined,
        useTls: typeof flags.useTls === 'boolean' ? flags.useTls : undefined,
        name: typeof flags.name === 'string' ? flags.name : undefined,
        tpl: typeof flags.tpl === 'string' ? flags.tpl : undefined,
    };
    if (flags.version) {
        return { cmd: 'version', options };
    }
    else if (flags.help) {
        return { cmd: 'help', options };
    }
    const cmd = flags._[2];
    switch (cmd) {
        case 'init':
            return { cmd: 'init', options };
        case 'dev':
            return { cmd: 'dev', options };
        case 'build':
            return { cmd: 'build', options };
        case 'preview':
            return { cmd: 'preview', options };
        case 'check':
            return { cmd: 'check', options };
        case 'config':
            return { cmd: 'config', options };
        case 'clean':
            return { cmd: 'clean', options };
        default:
            return { cmd: 'help', options };
    }
};
/** Display --help flag */
const printHelp = () => {
    console.error(`  ${colors.bold('vanil')} - less is enlightening
  ${colors.bold('Commands:')}
  vanil dev             Run Vanil in development mode.
  vanil build           Build a pre-compiled production version of your site.
  vanil preview         Preview your build locally before deploying.
  vanil config          Prints the final config and explains how to customize it.
  vanil clean           Removes the dist folder of your site; this cleans the cache.
  vanil check           Check your project for errors.
  vanil init <dir>      Scaffolds a new project in <dir>.
  ${colors.bold('Flags:')}
  --project-root <path> Specify the path to the project root folder, relative to CWD.
  --site <uri>          Specify site to use as site location.
  --use-tls             Enables https:// for all URIs.
  --dist                Specify the distribution folder (build result).
  --port <number>       Specify port to serve on (dev, preview only).
  --hostname <string>   Specify hostname to serve on (dev, preview only).
  --no-sitemap          Disable sitemap generation (build only).
  --version             Show the version number and exit.
  --help                Show this help message.
  --name <project-name> Name of the project (only useful with "init").
  --tpl <dir-or-repo>   Path to a template folder or git repository.
`);
};
/** get vanil config from package.json */
const getProjectPackageJson = (projectRoot) => JSON.parse((0, file_1.readFileSyncUtf8)((0, path_1.resolve)(projectRoot, 'package.json')));
/** display --version flag */
const printVersion = async () => {
    console.error(getProjectPackageJson((0, path_1.resolve)(__dirname, '..', '..')).version);
};
/** print the final config and explains how to customize it */
const printConfig = (config) => {
    console.log('');
    console.log('Raw config after finalizing:');
    console.log('');
    console.log(JSON.stringify(config, null, 2));
    console.log('');
    console.log('You can customize the project configuration by ');
    console.log('setting/changing the value of the property "vanil"');
    console.log('in the package.json file like this:');
    console.log('');
    console.log('// in package.json:');
    console.log(JSON.stringify({
        name: 'your_project_name',
        vanil: {},
    }, null, 2));
    console.log('');
    console.log('In case you need to change the config by environment, ');
    console.log('set VANIL_CONFIG as an environment variable and assign ');
    console.log('the stringified value of your vanil config JSON.');
};
/** merge CLI flags & config options (CLI flags take priority) */
const mergeCLIFlags = (config, flags) => {
    if (typeof flags.dist === 'string')
        config.dist = flags.dist;
    if (typeof flags.sitemap === 'boolean')
        config.buildOptions.sitemap = flags.sitemap;
    if (typeof flags.site === 'string')
        config.buildOptions.site = flags.site;
    if (typeof flags.port === 'number')
        config.devOptions.port = flags.port;
    if (typeof flags.hostname === 'string')
        config.devOptions.hostname = flags.hostname;
    if (typeof flags.useTls === 'boolean')
        config.devOptions.useTls = flags.useTls;
};
/** The primary CLI action */
const cli = async (args) => {
    const flags = (0, yargs_parser_1.default)(args);
    const state = resolveArgs(flags);
    const options = { ...state.options };
    const projectRootOverride = options.projectRoot || flags._[3];
    let userConfig = {
        buildOptions: {},
        devOptions: {},
    };
    const defaultConfig = (0, config_1.getDefaultConfig)();
    if (projectRootOverride) {
        // if a custom projectRoot was set by a flag like --project-root,
        // relatively resolve it to current process.cwd()
        // current cwd can be futher modified by using npm --prefix $dir $command
        defaultConfig.projectRoot = (0, path_1.resolve)(defaultConfig.projectRoot, projectRootOverride);
    }
    // support for package.json provided vanil config
    try {
        const userConfigCandidate = getProjectPackageJson(defaultConfig.projectRoot).vanil;
        if (userConfigCandidate) {
            userConfig = userConfigCandidate;
        }
    }
    catch (e) {
        // it's fine, this can happen e.g. on vanil init or when running the CLI
        // in a directory where there is no package.json at all
    }
    // read project .env files
    dotenv.config({ path: (0, path_1.resolve)(defaultConfig.projectRoot, '.env') });
    // support for ENV provided VANIL_CONFIG
    if (process.env.VANIL_CONFIG) {
        try {
            userConfig = JSON.parse(process.env.VANIL_CONFIG);
        }
        catch (e) {
            throwAndExit(e);
        }
    }
    const config = {
        // apply defaults
        ...defaultConfig,
        ...userConfig,
        // override by vanil config options set in package.json (maybe)
        buildOptions: {
            ...defaultConfig.buildOptions,
            ...userConfig.buildOptions,
        },
        devOptions: {
            ...defaultConfig.devOptions,
            ...userConfig.devOptions,
        },
    };
    try {
        // override config options by CLI parameters
        mergeCLIFlags(config, options);
        // e.g. evaluate site from hostname + port if not set
        (0, config_1.finalizeConfig)(config);
    }
    catch (err) {
        console.error(colors.red(err.toString() || err));
        process.exit(1);
    }
    // reset console
    console.clear();
    console.log(colors.dim('>'), `${colors.bold(colors.yellow('vanil'))} ${colors.magenta(colors.bold(state.cmd))}`, colors.cyan(`(${(0, config_1.getExecutionMode)()})`), colors.gray('...'));
    const runDev = async (config) => {
        try {
            await (0, dev_1.dev)(config);
        }
        catch (err) {
            printError(err);
        }
    };
    switch (state.cmd) {
        case 'help': {
            printHelp();
            process.exit(0);
        }
        case 'version': {
            await printVersion();
            process.exit(0);
        }
        case 'config': {
            await printConfig(config);
            process.exit(0);
        }
        case 'dev': {
            runDev(config);
            return;
        }
        case 'build': {
            try {
                await (0, build_1.build)(config);
                process.exit(0);
            }
            catch (err) {
                throwAndExit(err);
            }
            return;
        }
        case 'check': {
            process.exit(await (0, check_1.check)(config));
        }
        case 'preview': {
            try {
                // run forever
                await (0, preview_1.preview)(config);
            }
            catch (err) {
                throwAndExit(err);
            }
            return;
        }
        case 'clean': {
            process.exit((0, clean_1.clean)(config));
        }
        case 'init': {
            try {
                await (0, init_1.init)(options, flags._[3]);
            }
            catch (err) {
                throwAndExit(err);
            }
            process.exit(0);
        }
        default: {
            throw new Error(`Error running ${state.cmd}`);
        }
    }
};
exports.cli = cli;
const printError = (err) => console.error(colors.red(err.toString() || err));
/** Display error and exit */
const throwAndExit = (err) => {
    printError(err);
    process.exit(1);
};
