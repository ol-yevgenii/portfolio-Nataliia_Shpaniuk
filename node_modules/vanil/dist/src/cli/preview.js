"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printServerRunning = exports.preview = void 0;
const colors = __importStar(require("kleur/colors"));
const express_1 = __importDefault(require("express"));
const folders_1 = require("../core/io/folders");
const orchestrate_1 = require("../core/orchestrate");
const config_1 = require("../core/config");
const hook_1 = require("../core/hook/hook");
const http_1 = require("http");
const https_1 = require("https");
const path_1 = require("path");
const fs_1 = require("fs");
const file_1 = require("../core/io/file");
/** preview HTTP server that exactly mimics a static webserver */
const preview = async (config, autoListen = true) => {
    var _a, _b, _c, _d;
    const app = (0, express_1.default)();
    const distFolder = (0, folders_1.getDistFolder)(config);
    const context = await (0, orchestrate_1.setupContext)({
        config,
        command: 'preview',
        mode: (0, config_1.getExecutionMode)(),
    });
    app.use('/*', (req, res, next) => {
        if (res.statusCode >= 400) {
            console.log(`${req.method} ${colors.red(res.statusCode)} ${req.path}`);
        }
        next();
    });
    // serve all files from the dist folder
    app.use('/', express_1.default.static(distFolder, {
        etag: false,
        setHeaders: (res, path, stat) => {
            const targetDir = (0, path_1.resolve)((0, folders_1.getDistFolder)(config), path);
            // it's not a directory (directory requests never end up here),
            // but also has no file extension; default to text/html
            if (!targetDir.match(/\.[0-9a-z]+$/i)) {
                // this is necessary for config.buildOptions?.pageUrlFormat === 'directory'
                // because express.static doesn't support the no-file-extension "serve as HTML"
                // case by default
                res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            }
        },
        index: ((_a = config.buildOptions) === null || _a === void 0 ? void 0 : _a.pageUrlFormat) === 'directory' ? 'index' : 'index.html',
    }));
    // custom 404 page handler support
    app.get('/*', (req, res, next) => {
        var _a;
        const page404 = ((_a = config.buildOptions) === null || _a === void 0 ? void 0 : _a.pageUrlFormat) === 'directory' ? '404' : '404.html';
        const target404PageHtml = (0, path_1.resolve)((0, folders_1.getDistFolder)(config), page404);
        if ((0, fs_1.existsSync)(target404PageHtml)) {
            res.status(404).send((0, file_1.readFileSyncUtf8)(target404PageHtml));
            next();
        }
        else {
            const notFoundError = `ERROR 404: ${req.path} not found! 
      You can implement a custom 404 page by creating a 404.astro page template. 
      Resources can be placed in the ./public folder for static file serving.`;
            res.status(404).send(notFoundError);
            next();
        }
    });
    let tlsOptions = {};
    if ((_b = config.devOptions) === null || _b === void 0 ? void 0 : _b.useTls) {
        tlsOptions = { ...config.devOptions.tlsOptions };
        const projectRootFolder = (0, folders_1.getProjectRootFolder)(config);
        console.log('[config.devOptions] TLS enabled (devOptions.useTls). Trying to read key/cert relative to', projectRootFolder, tlsOptions);
        try {
            tlsOptions.cert = (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(projectRootFolder, tlsOptions.cert));
            tlsOptions.key = (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(projectRootFolder, tlsOptions.key));
        }
        catch (err) {
            console.error(colors.red('Error reading TLS certificate files:'));
            console.error(colors.red(String(err)));
            console.error(colors.yellow('Did you miss creating (self-signed) TLS key files?'));
            console.log();
            console.error(colors.yellow("e.g.> openssl req -x509 -new -nodes -keyout key.pem -out cert.pem -days 365 -subj '/CN=localhost'"));
            console.log();
            console.error(colors.yellow('NEVER GIT COMMIT CRYPTOGRAPHIC KEY FILES!'));
            console.error(colors.white('e.g. see: https://www.sitepoint.com/how-to-use-ssltls-with-node-js'));
            process.exit(1);
        }
    }
    const server = ((_c = config.devOptions) === null || _c === void 0 ? void 0 : _c.useTls) ? (0, https_1.createServer)(tlsOptions, app) : (0, http_1.createServer)(app);
    // automatically start to listen on port
    // is deactivated when dev CLI command hooks into this
    if (autoListen) {
        // register in context for onDevServerStart hooks to apply
        context.devServer = server;
        await (0, hook_1.runHooks)('onDevServerStart', context);
        server.listen((_d = config.devOptions) === null || _d === void 0 ? void 0 : _d.port, () => (0, exports.printServerRunning)('PreviewServer', config));
    }
    return {
        app,
        server,
    };
};
exports.preview = preview;
const printServerRunning = (tag, config) => {
    var _a;
    console.log(colors.magenta(colors.bold(`${tag} online`)), colors.gray('@'), colors.cyan((_a = config.buildOptions) === null || _a === void 0 ? void 0 : _a.site));
    console.log(colors.dim('Serving files from dist folder: '), colors.dim((0, folders_1.toProjectRootRelativePath)((0, folders_1.getDistFolder)(config), config)));
};
exports.printServerRunning = printServerRunning;
