"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.orchestrateTransformSingle = exports.orchestrateTransformAll = exports.setupContext = void 0;
const folders_1 = require("./io/folders");
const context_1 = require("./transform/context");
const transform_1 = require("./transform/transform");
const fast_glob_1 = __importDefault(require("fast-glob"));
const colors = __importStar(require("kleur/colors"));
const hook_1 = require("./hook/hook");
const routing_1 = require("./transform/routing");
const persist_1 = require("./transform/persist");
const path_1 = require("path");
const reset_1 = require("./runtime/reset");
const setupContext = async (context, doRegisterHooks = false) => {
    (0, context_1.validateContext)(context);
    if (doRegisterHooks) {
        await (0, hook_1.registerHooks)(context);
    }
    (0, reset_1.resetVanilPageIsolatedRuntimeState)();
    await (0, hook_1.runHooks)('onContext', context);
    return context;
};
exports.setupContext = setupContext;
/** organizes the flow of transformation for a full *.astro transform request including hooks */
const orchestrateTransformAll = async (context) => {
    await (0, exports.setupContext)(context, true);
    await (0, hook_1.runHooks)('onDevServerStart', context);
    await (0, hook_1.runHooks)('onStart', context);
    const astroFiles = fast_glob_1.default.sync(`${(0, folders_1.getPagesFolder)(context.config)}/**/*.astro`);
    console.log(colors.white('Render all .astro templates...'), astroFiles.map((file) => (0, folders_1.toProjectRootRelativePath)(file, context.config)));
    for (let i = 0; i < astroFiles.length; i++) {
        context = await (0, exports.orchestrateTransformSingle)({
            ...context,
            path: astroFiles[i],
        });
    }
    await (0, hook_1.runHooks)('onFinish', context);
    return context;
};
exports.orchestrateTransformAll = orchestrateTransformAll;
/** organizes the flow of transformation for a single .astro transform request including hooks */
const orchestrateTransformSingle = async (context) => {
    await (0, exports.setupContext)(context);
    await (0, hook_1.runHooks)('onBeforePage', context);
    console.log(colors.white(context.materializedPath ? '>' : 'Rendering'), colors.green(context.materializedPath
        ? (0, folders_1.toProjectRootRelativePath)(context.materializedPath, context.config)
        : (0, folders_1.toProjectRootRelativePath)(context.path, context.config)), colors.grey('...'));
    // makes sure, initial recognition of dynamic paths is happening, including processing
    // then recursively transform each permutation
    if ((0, folders_1.isDynamicRoutingPath)(context.path) && !context.materializedPath) {
        let materializedPages = [];
        try {
            materializedPages = await (0, routing_1.materializeDynamicRoutingPaths)(context);
        }
        catch (e) {
            console.error('ERROR: SSG Node.js execution error', e.original);
            // persist custom 404 page with error message
            context.materializedPath = (0, path_1.resolve)((0, folders_1.getPagesFolder)(context.config), '404.astro');
            (0, persist_1.persistVanilPage)(context, await (0, transform_1.renderError)(context, e));
            throw new Error('Failed to get static paths for rendering (see above)');
        }
        for (let i = 0; i < materializedPages.length; i++) {
            const dynamicPageContext = await (0, exports.orchestrateTransformSingle)({
                ...context,
                ...materializedPages[i],
            });
            // create an entry for the dynamic page materialized,
            // so that HMR can trigger well for those pages,
            // dependencies are the same for each page, so there is
            // potential to save on memory here (mark as dynamic page and ref
            // instead of duplicate the same object over and over again)
            // remember code cached
            context.codeCache = {
                ...dynamicPageContext.codeCache,
            };
            // remember materializedHtmlFilePaths
            if (dynamicPageContext.materializedHtmlFilePaths[context.path]) {
                dynamicPageContext.materializedHtmlFilePaths[context.path].forEach((path) => (0, context_1.addMaterializedHtmlFilePath)(path, context));
            }
            // adding the materialized path
            //addMaterializedPath(materializedPages[i].materializedPath, context)
        }
        return context;
    }
    await (0, transform_1.transformAndPersistSingle)(context);
    await (0, hook_1.runHooks)('onAfterPage', context);
    return context;
};
exports.orchestrateTransformSingle = orchestrateTransformSingle;
