"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runHooks = exports.registerHooks = exports.loadCoreHooks = exports.loadProjectHooks = exports.registerHook = exports.isHookFile = exports.isHookName = exports.HOOK_NAMES = void 0;
const path_1 = require("path");
const hook_1 = require("../config/hook");
const folders_1 = require("../io/folders");
const fast_glob_1 = __importDefault(require("fast-glob"));
const copyPublicToDist_1 = require("./core/copyPublicToDist");
const genManifestJson_1 = require("./core/genManifestJson");
const genRobotsTxt_1 = require("./core/genRobotsTxt");
const genServiceWorker_1 = require("./core/genServiceWorker");
const genSitemapXml_1 = require("./core/genSitemapXml");
const copyPanicOverlayToDist_1 = require("./core/copyPanicOverlayToDist");
const file_1 = require("../io/file");
const transpile_1 = require("../transform/transpile");
const vm_1 = require("../transform/vm");
exports.HOOK_NAMES = ['onContext', 'onDevServerStart', 'onStart', 'onBeforePage', 'onAfterPage', 'onFinish'];
const isHookName = (hookName) => exports.HOOK_NAMES.indexOf(hookName) > -1;
exports.isHookName = isHookName;
/** matches a file paths basename (file name) without extensions with an allowed hook name */
const isHookFile = (path) => {
    if (!path)
        return false;
    const hookName = (0, path_1.basename)(path).split('.')[0];
    return (0, exports.isHookName)(hookName);
};
exports.isHookFile = isHookFile;
const registerHook = (context, stage, fn) => {
    context.hooks.perStage[stage].push(fn);
};
exports.registerHook = registerHook;
/** globs hooks in a projects hooks folder, requires them and registers valid hook functions  */
const loadProjectHooks = async (context) => {
    const hookFiles = fast_glob_1.default.sync(`${(0, folders_1.getHooksFolder)(context.config)}/*.{ts,jsm,js}`);
    if (hookFiles.length) {
        console.log('Found custom project hooks:', hookFiles.map((hookFilePath) => (0, folders_1.toProjectRootRelativePath)(hookFilePath, context.config)));
    }
    for (let i = 0; i < hookFiles.length; i++) {
        const hookFile = hookFiles[i];
        if ((0, exports.isHookFile)(hookFile)) {
            const hookFileDir = (0, path_1.dirname)(hookFile);
            const hookScript = (0, transpile_1.transpileSSGCode)((0, file_1.readFileSyncUtf8)(hookFile), context, hookFileDir);
            const currentCwd = process.cwd();
            context.path = hookFileDir;
            process.chdir(hookFileDir);
            const exportedSymbols = await (0, vm_1.run)(hookScript, context);
            process.chdir(currentCwd);
            const hookStageNames = Object.keys(exportedSymbols.data);
            if (hookStageNames.length > 0) {
                hookStageNames.forEach((hookStageName) => {
                    if ((0, exports.isHookName)(hookStageName)) {
                        console.log(`Custom hook "${hookStageName}" registered.`);
                        (0, exports.registerHook)(context, hookStageName, exportedSymbols.data[hookStageName]);
                    }
                });
            }
        }
    }
};
exports.loadProjectHooks = loadProjectHooks;
/** registers core hooks to execute standard functionality */
const loadCoreHooks = async (context) => {
    await (0, exports.registerHook)(context, 'onStart', copyPublicToDist_1.copyPublicToDist);
    await (0, exports.registerHook)(context, 'onStart', copyPanicOverlayToDist_1.copyPanicOverlayToDist);
    await (0, exports.registerHook)(context, 'onFinish', genManifestJson_1.genManifestJson);
    await (0, exports.registerHook)(context, 'onFinish', genRobotsTxt_1.genRobotsTxt);
    await (0, exports.registerHook)(context, 'onFinish', genServiceWorker_1.genServiceWorker);
    await (0, exports.registerHook)(context, 'onFinish', genSitemapXml_1.genSitemapXml);
};
exports.loadCoreHooks = loadCoreHooks;
/** imports the hooks that may be found in a project */
const registerHooks = async (context) => {
    // skip hook registration in case it already happened
    if (!context.hooks.initialized || (0, exports.isHookFile)(context.path)) {
        context.hooks = (0, hook_1.getDefaultHookConfig)(context);
        await (0, exports.loadCoreHooks)(context);
        await (0, exports.loadProjectHooks)(context);
        context.hooks.initialized = true;
    }
};
exports.registerHooks = registerHooks;
/** run hooks assigned for a specific state */
const runHooks = async (hookStage, context, props) => {
    const hooksPerStage = context.hooks.perStage[hookStage];
    for (let i = 0; i < hooksPerStage.length; i++) {
        await hooksPerStage[i](context, props);
    }
};
exports.runHooks = runHooks;
