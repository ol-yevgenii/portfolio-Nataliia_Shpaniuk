"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.materializeDOM = exports.injectVirtualDomElement = exports.createVirtualDomScriptElement = void 0;
const linkedom_1 = require("linkedom");
const vdom_1 = require("../runtime/vdom");
const bundle_1 = require("./bundle");
const transpile_1 = require("./transpile");
/** creates a <script> element with code */
const createVirtualDomScriptElement = (document, scriptCode, attributes) => {
    const scriptEl = document.createElement('script');
    scriptEl.setAttribute('type', 'text/javascript');
    if (attributes) {
        // e.g. role="state"
        Object.keys(attributes).forEach((attrName) => {
            scriptEl.setAttribute(attrName, attributes[attrName]);
        });
    }
    scriptEl.appendChild(document.createTextNode(scriptCode));
    return scriptEl;
};
exports.createVirtualDomScriptElement = createVirtualDomScriptElement;
/**
 * inserts as first child of the root element (usually <head>) if child nodes are
 * available, else appends to root element
 */
const injectVirtualDomElement = (rootElement, scriptElement) => {
    // e.g. <head> has child nodes, insert as first element
    if (rootElement.children.length > 0) {
        rootElement.insertBefore(scriptElement, rootElement.children.item(0));
    }
    else {
        // no childNodes, lets append
        rootElement.appendChild(scriptElement);
    }
};
exports.injectVirtualDomElement = injectVirtualDomElement;
/** materializes the virtual DOM into a DOM string, ergo "HTML" */
const materializeDOM = async (executionResult, context) => {
    var _a;
    const virtualDOM = executionResult.data;
    const { document } = (0, linkedom_1.parseHTML)('');
    const dt0 = Date.now();
    // create synthetic <html> top-level element
    const htmlElement = document.createElement('html');
    document.appendChild(htmlElement);
    // mark root element
    virtualDOM['attributes'] = { root: 'root' };
    // TODO: mid-term goal: perf: linkedom can be probably constructed directly in tsx()
    // transform VDOM into linkedom
    (0, vdom_1.getAbstractDOM)(document, context)(virtualDOM, htmlElement);
    // actual virtualDOM top-level element (no matter what type it is),
    // which was marked as root element above
    const actualTopLevelElement = document.querySelector(`${virtualDOM.type}[root=root]`);
    // cleanup; remove attribute form resulting DOM
    actualTopLevelElement === null || actualTopLevelElement === void 0 ? void 0 : actualTopLevelElement.removeAttribute('root');
    // replace synthetic top-level <html> by marked root element
    // whereas <html> is always available, because parseHTML('')
    // internally constructs a shallow <html> element
    // which is to be replaced by the actualTopLevelElement
    (_a = document.querySelector('html')) === null || _a === void 0 ? void 0 : _a.replaceWith(actualTopLevelElement);
    // const dt1 = Date.now()
    // top-level element is an <html> element,
    // means we're dealing with a page, not a component
    if ((actualTopLevelElement === null || actualTopLevelElement === void 0 ? void 0 : actualTopLevelElement.localName) === 'html') {
        // TODO: perf: don't do this here; accumulate flags incrementally after each transpile
        //const runtimeLibraryFeatureFlags = detectRuntimeLibraryFeatures(html, context.mode)
        // hoise top-level interactive runtime in pages
        await (0, bundle_1.injectInteractiveRuntimeLibrary)(document, document.head, context, executionResult.state);
    }
    // console.log('elapsed injectRuntime', Date.now() - dt1)
    const newCode = (0, transpile_1.replaceStyleReplacements)((0, transpile_1.uncapeCurlyBracketsAndBackticks)(document.toString()), context);
    return newCode;
};
exports.materializeDOM = materializeDOM;
