"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapeAndNumbInlineStyleAndScriptTags = exports.uncapeCurlyBracketsAndBackticks = exports.escapeCurlyBracketsAndBackticks = exports.loadAndTranspileCode = exports.replaceStyleReplacements = exports.transpileStyleCode = exports.transpileTSX = exports.transpileRuntimeInteractiveScriptCode = exports.transpileSSGCode = exports.inlineTranspileAbsoluteRequires = exports.inlineTranspileImportedVanilComponents = exports.transpileTemplate = exports.stripGetStaticPathsFnDecl = exports.TS_IMPORT_POLYFILL_SCRIPT = void 0;
const parse_1 = require("./parse");
const typescript_1 = __importDefault(require("typescript"));
const rewritepath_1 = require("./typescript/rewritepath");
const resolve_1 = require("./resolve");
const bundle_1 = require("./bundle");
const file_1 = require("../io/file");
const transform_1 = require("./transform");
const context_1 = require("./context");
const cache_1 = require("./cache");
const path_1 = require("path");
const postcss = require('postcss');
const RE_TS_EXPORTS_COMMONJS_INIT = /exports\.[\s\S]*?void 0;\n/;
const RE_HAS_ASYNC_CODE = /await[\S]*/;
exports.TS_IMPORT_POLYFILL_SCRIPT = `"use strict";
Object.defineProperty(exports, "__esModule", { value: true });`;
/** strips away the getStaticPaths function impl that may occur
 * in dynamic routing .astro page templates.
 * These use "export" which is prohibited here because we're
 * running the code in a CommonJS setting */
const stripGetStaticPathsFnDecl = (code, context) => code
    .replace(/export(.*?)getStaticPaths/, 'getStaticPaths')
    .replace(`${context.isolatedGetStaticPathsFnCode}`, '');
exports.stripGetStaticPathsFnDecl = stripGetStaticPathsFnDecl;
/** takes the typeScriptCode and htmlCode; transpiles into an atomic async function */
const transpileTemplate = (codeBundle, context) => {
    const importsAndCode = (0, parse_1.splitTopLevelImports)(codeBundle.typeScriptCode);
    const preparedTSXCode = (0, exports.escapeAndNumbInlineStyleAndScriptTags)(codeBundle.htmlCode, context);
    // e.g. .astro components should be sync
    const hasAsyncImpl = !!RE_HAS_ASYNC_CODE.test(importsAndCode.codeStatements);
    let scriptCode = `\n
    // merge runtime and context-provided parts to a uniform global object
    // where direct use of Vanil and access to globalThis.Vanil is both valid
    globalThis.Vanil = Vanil = { ...(globalThis.Vanil || {}), ...(Vanil || {}), tsx }

    // Astro compatibility
    globalThis.Astro = Astro = Vanil;

    // Vanil template Node.js SSG imports (re-ordered)
    ${importsAndCode.importStatements}
    
    // makes sure component .astro templates render sync
    export default ${hasAsyncImpl ? 'async' : ''}() => {

        // Vanil template Node.js SSG code
        ${(0, exports.stripGetStaticPathsFnDecl)(importsAndCode.codeStatements, context)}

        // evaluation of CSS styles via executing template literals
        // and storing the computation result in context
        ${context.styleReplacements.map((styleReplacement, index) => `
            if (Vanil.props.context.styleReplacements[${index}]) {
              Vanil.props.context.styleReplacements[${index}].replacement = 
                \`${styleReplacement.original}\`
            }
            `)}
        
        return ( ${preparedTSXCode} )
    }\n
    `;
    const cachedCode = (0, cache_1.getFromCache)(scriptCode, context);
    if (cachedCode)
        return cachedCode;
    let transpiledCode = typescript_1.default
        .transpileModule(scriptCode, {
        ...context.transpileOptions,
        transformers: {
            // relative imports must be re-written to apply the
            // specific sourcePath-relative import logic
            // (code is evaluated in runtime scope of vanil later)
            before: [
                (0, rewritepath_1.transformImportPaths)({
                    rewrite: (importPath) => (0, resolve_1.resolveNodeImport)(importPath, context),
                }),
            ],
        },
    })
        .outputText.replace(exports.TS_IMPORT_POLYFILL_SCRIPT, '');
    // make sure SSG code can import .astro component templates
    transpiledCode = (0, exports.inlineTranspileImportedVanilComponents)(transpiledCode, context);
    // const dt = Date.now()
    transpiledCode = (0, exports.inlineTranspileAbsoluteRequires)(transpiledCode, context);
    // console.log('elapsed', Date.now() - dt)
    // top-level import statements come first
    // async immediately invoked function execution follows (a-iife)
    // providing a local Vanil argument including all config properties
    // and the path to the source template
    // a-iife starts with the rest of the code (imports stipped and reordered on top),
    // followed by returning the htmlCode which is assumed to be JSX/TSX
    return (0, cache_1.addToCache)(scriptCode, transpiledCode, context /** TODO: broken */);
};
exports.transpileTemplate = transpileTemplate;
const transpileInlineVanilComponent = (importPath, context) => {
    // make sure the .astro page template will HMR when this .astro
    // component dependency changes
    (0, context_1.addFileDependency)(importPath, context);
    // .astro template page path
    let _contextPath = context.path;
    // for component transpilation change path to component path
    context.path = importPath;
    context.isProcessingComponent = true;
    // stash/reset style replacements as they shouldn't affect relative .astro components
    const _styleReplacements = context.styleReplacements;
    context.styleReplacements = [];
    const transformedComponentCode = (0, transform_1.transformTemplate)(importPath, context);
    // reply style replacements and merge with potential new ones
    context.styleReplacements = [...context.styleReplacements, ..._styleReplacements];
    // reset to .astro template page path
    context.isProcessingComponent = false;
    context.path = _contextPath;
    // assigning the original local name here (too)
    // as this is a multi-step, isolated transpile without shared
    // name cache, locally declared names diverge
    return `{ default: (fn = function() {
    const _origVanilProps = { ...Vanil.props }
    const _origIsPage = Vanil.isPage
    let _contextPath = Vanil.props.context.path

    Vanil.props.context.path = '${importPath}'
    Vanil.isPage = false

    importVanilComponent(arguments[0])

    ${transformedComponentCode}\n

    const vdom = exports.default.apply(this, arguments)

    // restore Vanil.props to not leak/accumulate/override
    // them in outer scope
    Vanil.props.context.path = _contextPath
    Vanil.props = _origVanilProps
    Vanil.isPage = _origIsPage

    return vdom
  })}`;
};
/** inlines code of require() calls towards .astro component template files */
const inlineTranspileImportedVanilComponents = (transpiledCode, context) => (0, parse_1.processRequireFunctionCalls)(transpiledCode, (importPath) => {
    const cachedCode = (0, cache_1.getFromCache)(importPath, context);
    if (cachedCode)
        return cachedCode;
    const astroComponentInlineCode = transpileInlineVanilComponent(importPath, context);
    (0, context_1.addFileDependency)(importPath, context);
    return (0, cache_1.addToCache)(importPath, astroComponentInlineCode, context, false /** TODO: borken */);
}, '.astro');
exports.inlineTranspileImportedVanilComponents = inlineTranspileImportedVanilComponents;
const inlineTranspileAbsoluteRequires = (transpiledCode, context) => {
    const code = (0, parse_1.processRequireFunctionCalls)(transpiledCode, (importPath) => {
        const relativeContextPath = (0, path_1.dirname)(importPath);
        if (!(0, resolve_1.isAbsoluteFileImportTarget)(importPath)) {
            return `require('${importPath}')`;
        }
        const cachedCode = (0, cache_1.getFromCache)(importPath, context);
        if (cachedCode)
            return cachedCode;
        const transpiledRequireCode = (0, exports.transpileSSGCode)((0, file_1.readFileSyncUtf8)((0, resolve_1.materializePathSelectFile)(importPath)), context, relativeContextPath);
        const retCode = `
        (() => { 
          exports = exports || {}
          let __dirname = '${relativeContextPath}'; 
          let __filename = "${importPath}"; 
          let _contextPath = Vanil.props.context.path
          Vanil.props.context.path = '${importPath}'

          ${transpiledRequireCode}; 
          
          Vanil.props.context.path = _contextPath
          
          return exports 
        })();
      `;
        return (0, cache_1.addToCache)(importPath, retCode, context /** TODO: broken, needs invalidation */);
    });
    return code;
};
exports.inlineTranspileAbsoluteRequires = inlineTranspileAbsoluteRequires;
/** transpiles SSG code in general */
const transpileSSGCode = (scriptCode, context, relImportPath) => {
    const cachedCode = (0, cache_1.getFromCache)(scriptCode, context);
    if (cachedCode)
        return cachedCode;
    // pre-process vanil imports
    scriptCode = (0, transform_1.transformVanilImports)(scriptCode);
    scriptCode = `
    __dirname = '${relImportPath ? relImportPath : context.path}'; 
    __filename = "${context.path}"; 
    ${scriptCode}
  `;
    let transpiledCode = typescript_1.default
        .transpileModule(scriptCode, {
        ...context.transpileOptions,
        transformers: {
            // relative imports must be re-written to apply the
            // specific sourcePath-relative import logic
            // (code is evaluated in runtime scope of vanil later)
            before: [
                (0, rewritepath_1.transformImportPaths)({
                    rewrite: (importPath) => (0, resolve_1.resolveNodeImport)(importPath, context, relImportPath),
                }),
            ],
        },
    })
        .outputText.replace(exports.TS_IMPORT_POLYFILL_SCRIPT, '');
    // TODO: make sure SSG code can import .astro component templates
    //transpiledCode = inlineTranspileImportedVanilComponents(transpiledCode, context)
    // TODO: necessary call? shouldn't transpileTemplate be catch-all in the end?
    transpiledCode = (0, exports.inlineTranspileAbsoluteRequires)(transpiledCode, context);
    // top-level import statements come first
    // async immediately invoked function execution follows (a-iife)
    // providing a local Vanil argument including all config properties
    // and the path to the source template
    // a-iife starts with the rest of the code (imports stipped and reordered on top),
    // followed by returning the htmlCode which is assumed to be JSX/TSX
    return (0, cache_1.addToCache)(scriptCode, transpiledCode, context /** TODO: borken, needs invalidation */);
};
exports.transpileSSGCode = transpileSSGCode;
/** transpiles and wraps runtime code; cares for re-ordering imports */
const transpileRuntimeInteractiveScriptCode = (scriptCode, splitImports = true, path = '.', injectionIntent = 'import', context) => {
    let code = scriptCode;
    let transpiledCode = (0, cache_1.getFromCache)(scriptCode, context);
    if (!transpiledCode) {
        if (splitImports) {
            const importsAndCode = (0, parse_1.splitTopLevelImports)(scriptCode);
            // support for top-level await
            code = `${importsAndCode.importStatements}
                ${(0, transform_1.mayWrapInAsyncIIFE)(importsAndCode.codeStatements)}`;
        }
        transpiledCode = (0, exports.transpileTSX)(code, context, injectionIntent);
        // hoisted code might need an async() iife wrapper,
        // while imported code is safely wrapped already
        if (injectionIntent === 'hoist') {
            transpiledCode = (0, transform_1.mayWrapInAsyncIIFE)(transpiledCode);
        }
        (0, cache_1.addToCache)(scriptCode, transpiledCode, context);
    }
    return (0, bundle_1.bundleRequires)(transpiledCode, path, context);
};
exports.transpileRuntimeInteractiveScriptCode = transpileRuntimeInteractiveScriptCode;
/** transpiles arbitrary ts/tsx code as CJS module type code */
const transpileTSX = (code, context, injectionIntent = 'import') => {
    const cachedCode = (0, cache_1.getFromCache)(code, context);
    if (cachedCode)
        return cachedCode;
    // pre-process vanil imports
    code = (0, transform_1.transformVanilImports)(code);
    let transpiledCode = typescript_1.default
        .transpileModule(code, {
        ...context.transpileOptions,
    })
        .outputText // typescript outputs an exports initializer that
        // counters the window-local unified exports object concept
        .replace(RE_TS_EXPORTS_COMMONJS_INIT, '')
        .replace(exports.TS_IMPORT_POLYFILL_SCRIPT, '');
    if (injectionIntent === 'import') {
        return (0, transform_1.mayDeclareExports)(transpiledCode);
    }
    return (0, cache_1.addToCache)(code, transpiledCode, context /** TODO: broken: need invalidation */);
};
exports.transpileTSX = transpileTSX;
/** transpiles style code using PostCSS; this is called from different stages */
const transpileStyleCode = (styleCode, attributes, context) => {
    const cachedCode = (0, cache_1.getFromCache)(styleCode, context);
    if (cachedCode)
        return cachedCode;
    // style code is relative the an .astro component
    // change the context for the time of processing
    // (resolve() fn impl. in import plugin is affected)
    let _contextPath = context.path;
    if (attributes.rel) {
        context.path = attributes.rel;
    }
    if (attributes.rel) {
        context.path = _contextPath;
    }
    return (0, cache_1.addToCache)(styleCode, postcss(context.postCssPlugins).process(styleCode).css, context, true);
};
exports.transpileStyleCode = transpileStyleCode;
/** style code that has been marked for post-processing is replaced here */
const replaceStyleReplacements = (htmlCode, context) => {
    for (let i = 0; i < context.styleReplacements.length; i++) {
        htmlCode = htmlCode.replace(context.styleReplacements[i].original, (0, exports.transpileStyleCode)(context.styleReplacements[i].replacement, context.styleReplacements[i].attributes, context));
    }
    return htmlCode;
};
exports.replaceStyleReplacements = replaceStyleReplacements;
/** helper function, used to transpile code hoised in tsx() transform  */
const loadAndTranspileCode = (absolutePath, type, attributes, injectionIntent = 'import', context) => {
    const fileContents = (0, file_1.readFileSyncUtf8)(absolutePath);
    switch (type) {
        case 'css':
            return (0, exports.transpileStyleCode)(fileContents, attributes, context);
        case 'js':
        default:
            return (0, exports.transpileRuntimeInteractiveScriptCode)(fileContents, false, absolutePath, injectionIntent, context);
    }
};
exports.loadAndTranspileCode = loadAndTranspileCode;
/** escapes syntax characters prone to immediate evaluation */
const escapeCurlyBracketsAndBackticks = (code) => {
    return code
        .replace(/`/gm, '__VANIL_BACKTICK__')
        .replace(/\{/gm, '__VANIL_CURLY_BACKET_OPEN__')
        .replace(/\}/gm, '__VANIL_CURLY_BACKET_CLOSE__');
};
exports.escapeCurlyBracketsAndBackticks = escapeCurlyBracketsAndBackticks;
/** unescapes syntax characters prone to immediate evaluation */
const uncapeCurlyBracketsAndBackticks = (code) => {
    return code
        .replace(/__VANIL_BACKTICK__/gm, '`')
        .replace(/__VANIL_CURLY_BACKET_OPEN__/gm, '{')
        .replace(/__VANIL_CURLY_BACKET_CLOSE__/gm, '}');
};
exports.uncapeCurlyBracketsAndBackticks = uncapeCurlyBracketsAndBackticks;
/** wraps innerText JSX node content in curly backets to block evaluation */
const wrapInJSXCurlyBracketsString = (code) => `{\`${code}\`}`;
// 1. escape { and ` characters globally (1st step numbing)
// 2. wrap in {``} to really numb the code while in SSG evaluation regarding TSX transforms
const numbCodeForSSGEvaluation = (code) => wrapInJSXCurlyBracketsString((0, exports.escapeCurlyBracketsAndBackticks)(code));
/**
 * escapes and transpiles inline script code before it is passed to the
 * server-side transpiler and evaluation; this is necessary to "numb" such
 * runtime-interactive code as it shouldn't be executed server-side at all
 */
const escapeAndNumbInlineStyleAndScriptTags = (tsxCode, context) => {
    // walk thru all <script> tags and
    // 1. transpile them (.ts -> .js)
    // 2. numb code for SSG evaluation
    tsxCode = (0, parse_1.processScriptTags)(tsxCode, (codeOfTag) => numbCodeForSSGEvaluation(codeOfTag));
    return (0, parse_1.processStyleTags)(tsxCode, (codeOfTag, attrs) => {
        // remember style to be evaluated via codegen
        context.styleReplacements.push({
            original: codeOfTag,
            replacement: codeOfTag,
            attributes: {
                ...attrs,
                ...(context.isProcessingComponent
                    ? {
                        // setting the .astro component relation so that
                        // @imports can be resolved relative to the component path
                        // not relative to the importing .astro page template path
                        rel: context.path,
                    }
                    : {}),
            },
        });
        return numbCodeForSSGEvaluation(codeOfTag);
    });
};
exports.escapeAndNumbInlineStyleAndScriptTags = escapeAndNumbInlineStyleAndScriptTags;
