"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFeatureFlags = exports.addMaterializedHtmlFilePath = exports.addFileDependency = exports.validateContext = void 0;
const postcss_1 = require("../config/postcss");
const transpileOptions_1 = require("../config/transpileOptions");
const hook_1 = require("../config/hook");
const loader_1 = require("../config/loader");
const folders_1 = require("../io/folders");
const bundle_1 = require("./bundle");
const cache_1 = require("./cache");
/** fills in emptiness such as initializing optional properties */
const validateContext = (context) => {
    if (!context.path)
        context.path = '';
    if (!context.materializedPath)
        context.materializedPath = '';
    // reset values per single page run
    context.styleReplacements = [];
    context.isProcessingComponent = false;
    if (!context.hooks) {
        context.hooks = (0, hook_1.getDefaultHookConfig)(context);
    }
    if (!context.loaderMap) {
        context.loaderMap = (0, loader_1.getDefaultLoaderMap)();
    }
    // defaut internal config
    context.transpileOptions = (0, transpileOptions_1.geTranspileOptions)(context);
    context.postCssPlugins = (0, postcss_1.getPostCSSPlugins)(context);
    // refs map of refName of
    // element in VDOM -> generated CSS selector query
    context.refs = {};
    // used to transmit params and props determined
    // via dynamic routing ([param] and [...param])
    if (!context.pageParamsAndProps) {
        context.pageParamsAndProps = {
            params: {},
            props: {},
        };
    }
    // maps from the .astro file path to the actual .html file paths in dist folder
    if (!context.materializedHtmlFilePaths) {
        context.materializedHtmlFilePaths = {};
    }
    // === only relevant for command: dev
    // file dependencies, used for tracing / triggering specific HMR
    // when dependencies of .astro page templates change
    if (!context.fileDependencies) {
        context.fileDependencies = {};
    }
    // used for caching materialized paths (for pages with dynamic routes)
    // as a map of context.path -> materializedPaths to know which actually
    // rendered out file did change
    //context.materializedPaths = {}
    // caches transpiled code for quick lookup and re-use across transforms
    // TODO: currently clearing cache on every .astro context enter;
    // should be persistent but needs a re-implementation therefore
    //if (!context.codeCache) {
    (0, cache_1.invalidateCache)(context);
    //}
    // invalidate runtime script and stylesheet injection cache per page
    context.pageRuntimeScriptsAndLinks = [];
    // cache materialized paths
    context.paths = {
        dist: (0, folders_1.getDistFolder)(context.config),
        public: (0, folders_1.getPublicFolder)(context.config),
        projectRoot: (0, folders_1.getProjectRootFolder)(context.config),
        hooks: (0, folders_1.getHooksFolder)(context.config),
        pages: (0, folders_1.getPagesFolder)(context.config),
    };
    if (!context.runtimeLibraryFeatureFlags) {
        context.runtimeLibraryFeatureFlags = {};
    }
    if (!context.fileDependenciesToRestartOn) {
        context.fileDependenciesToRestartOn = [];
    }
    return context;
};
exports.validateContext = validateContext;
/** adds a file dependency to the linked list */
const addFileDependency = (filePath, context) => {
    if (!context.fileDependencies[filePath])
        context.fileDependencies[filePath] = [];
    if (context.fileDependencies[filePath].indexOf(context.path) === -1) {
        // single filePath -> .astro template list
        context.fileDependencies[filePath].push(context.path);
    }
};
exports.addFileDependency = addFileDependency;
/** adds a materialized path to the map */
/*
export const addMaterializedPath = (materializedPath: string, context: Context) => {

    if (!context.materializedPaths![context.path!]) context.materializedPaths![context.path!] = []

    if (context.materializedPaths![context.path!].indexOf(materializedPath) === -1) {

        // context.path -> all materialized file paths of that dyanmic routing .astro template page
        context.materializedPaths![context.path!].push(materializedPath)
    }
}
*/
/** distinctively adds a materialized HTML file path to the map */
const addMaterializedHtmlFilePath = (materializedHtmlFilePath, context) => {
    if (!context.materializedHtmlFilePaths[context.path])
        context.materializedHtmlFilePaths[context.path] = [];
    if (context.materializedHtmlFilePaths[context.path].indexOf(materializedHtmlFilePath) === -1) {
        // context.path -> all materialized file paths of
        // that dyanmic routing .astro template page
        context.materializedHtmlFilePaths[context.path].push(materializedHtmlFilePath);
    }
};
exports.addMaterializedHtmlFilePath = addMaterializedHtmlFilePath;
/** accumulate runtime feature flags */
const addFeatureFlags = (featureFlags, context) => {
    (0, bundle_1.featureFlagsArray)(featureFlags).forEach((flag) => {
        if (featureFlags[flag]) {
            context.runtimeLibraryFeatureFlags[flag] = true;
        }
    });
};
exports.addFeatureFlags = addFeatureFlags;
