"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preprocessVanilComponentPropsAndSlots = exports.getStyleSheetHoisted = exports.getScriptHoisted = exports.astroFetchContent = exports.restartOnFileChange = void 0;
const fast_glob_1 = __importDefault(require("fast-glob"));
const resolve_1 = require("./resolve");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const transpile_1 = require("./transpile");
const raw_1 = require("../loader/core/raw");
const context_1 = require("./context");
const loader_1 = require("../loader/loader");
const fs_1 = require("fs");
const folders_1 = require("../io/folders");
const routing_1 = require("./routing");
globalThis.Vanil = {
    ...(globalThis.Vanil || {}),
};
// make isomorphic part of the runtime (i18n, store) available for SSG
// (automatically assigns to Vanil global object)
require("../runtime/store");
require("../runtime/i18n");
// built-in Components
require("../runtime/components/Script");
require("../runtime/components/Link");
require("../runtime/components/Debug");
require("../runtime/components/Code");
require("../runtime/components/Trans");
require("../runtime/components/Markdown");
const path_1 = require("path");
const tsx_1 = require("./tsx");
/** Vanil.reloadOnChange implementation to allow dynamic  */
const restartOnFileChange = (filePath, context) => {
    context.fileDependenciesToRestartOn.push(filePath);
};
exports.restartOnFileChange = restartOnFileChange;
globalThis.restartOnFileChange = exports.restartOnFileChange;
/** Vanil.fetchContent() implementation */
exports.astroFetchContent = (globalThis.vanilFetchContent = (targetPath, context) => {
    const targetPathSplits = targetPath.split(':');
    let requiredLoaderName;
    if ((0, loader_1.isLoaderRegistered)(targetPathSplits[0], context)) {
        // is the 'raw' in 'raw:../foo/bar.txt'
        requiredLoaderName = targetPathSplits[0];
        // is the '../foo/bar.txt'
        targetPath = targetPathSplits[1];
    }
    const resolvedPath = (0, resolve_1.resolvePathRelative)(targetPath, context.path);
    const candidates = [];
    // throw error and trigger panic report
    if (!(0, folders_1.isGlobPath)(resolvedPath) && !(0, fs_1.existsSync)(resolvedPath)) {
        try {
            (0, fs_1.accessSync)(resolvedPath, fs_1.constants.R_OK);
        }
        catch (e) {
            throw new Error(`Vanil.fetchContent('${targetPath}'): File isn't readable!`);
        }
    }
    // fast-glob sync resolve
    fast_glob_1.default.sync(resolvedPath).forEach((path) => {
        // all files fetched are also dependencies to the page, should HMR
        (0, context_1.addFileDependency)(path, context);
        // selects a specific loader if required by the user
        // alternatively, an automatic file extension matching
        // process is run
        const loaderRegistration = (0, loader_1.getMatchingLoader)(context, path, requiredLoaderName);
        candidates.push(loaderRegistration
            ? // some loader matched
                loaderRegistration.cb(path, context)
            : // in case neither the user decided for a loader
                // nor we could fine a matching loader for the file extension,
                // we'd fall back to the raw loader
                context.loaderMap[raw_1.RAW_LOADER_NAME].cb(path, context));
    });
    return candidates;
});
/** hoisting of relative <script> imports -> <script>code</script> */
const getScriptHoisted = (path, type, attributes, context) => (0, transpile_1.loadAndTranspileCode)(path, type, attributes, 'hoist', context);
exports.getScriptHoisted = getScriptHoisted;
/** hoisting of relative <link> imports -> <style> sheets */
const getStyleSheetHoisted = (path, type, attributes, context) => (0, transpile_1.loadAndTranspileCode)(path, type, attributes, 'hoist', context);
exports.getStyleSheetHoisted = getStyleSheetHoisted;
/** implements fetch() in a isomorphic way */
globalThis.fetch = cross_fetch_1.default;
/** checks that a path is neither absolute nor a remote URL */
globalThis.isRelativeSrcTarget = resolve_1.isRelativeSrcTarget;
/** resolves a relative local file path into an absolute */
globalThis.resolvePathRelative = (targetPath, path) => (0, path_1.resolve)((0, path_1.dirname)(path), targetPath);
/** hoists a CSS <link> by href */
globalThis.getStyleSheetHoisted = exports.getStyleSheetHoisted;
/** hoists a JS <script> by src */
globalThis.getScriptHoisted = exports.getScriptHoisted;
/**
 * chunks the data in slices of paginationParams.pageSize and
 * generates a page prop to be passed to each page
 */
globalThis.paginate = routing_1.paginate;
/** preprocesses props that are passed down to an .astro component on import like
 * import MyVanilComponent from "../components/my.astro" */
const preprocessVanilComponentPropsAndSlots = (props, Vanil) => {
    const propsKeys = Object.keys(props);
    // walks over all props passed to a component
    // and divides and conquers the "children" prop to
    // assign them to Vanil.slots, so tsx() can create the <slot>s later;
    // assigning all other props to Vanil.props
    for (let i = 0; i < propsKeys.length; i++) {
        if (propsKeys[i] === 'children') {
            const children = props[propsKeys[i]];
            if (Array.isArray(children)) {
                children.forEach((child) => {
                    // defined slot name
                    if (child.attributes && child.attributes.slot) {
                        Vanil.slots[child.attributes.slot] = {
                            type: 'fragment',
                            children: [child],
                        };
                    }
                    else {
                        let prevChildren = [];
                        if (Vanil.slots[tsx_1.SLOT_DEFAULT_NAME]) {
                            prevChildren = Vanil.slots[tsx_1.SLOT_DEFAULT_NAME].children
                                ? Vanil.slots[tsx_1.SLOT_DEFAULT_NAME].children
                                : // handling the else case when only a single child
                                    // has been assigned before
                                    [Vanil.slots[tsx_1.SLOT_DEFAULT_NAME]];
                        }
                        Vanil.slots[tsx_1.SLOT_DEFAULT_NAME] = {
                            type: 'fragment',
                            children: [...prevChildren, child],
                        };
                    }
                });
            }
        }
    }
    return props;
};
exports.preprocessVanilComponentPropsAndSlots = preprocessVanilComponentPropsAndSlots;
