"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformImportPaths = void 0;
const typescript_1 = __importDefault(require("typescript"));
const path_1 = require("path");
/** rewrites a relative import to absolute import or trigger rewrite callback */
const rewritePath = (importPath, sf, opts, regexps, localName) => {
    const aliases = Object.keys(regexps);
    for (const alias of aliases) {
        const regex = regexps[alias];
        if (regexps[alias].test(importPath)) {
            return importPath.replace(regex, opts.alias[alias]);
        }
    }
    if (typeof opts.rewrite === 'function') {
        const newImportPath = opts.rewrite(importPath, sf.fileName, localName);
        if (newImportPath) {
            return newImportPath;
        }
    }
    if (opts.project && opts.projectBaseDir && importPath.startsWith('.')) {
        const path = (0, path_1.resolve)((0, path_1.dirname)(sf.fileName), importPath).split(opts.projectBaseDir)[1];
        return `${opts.project}${path}`;
    }
    return importPath;
};
const isRequire = (node) => typescript_1.default.isCallExpression(node) &&
    typescript_1.default.isIdentifier(node.expression) &&
    node.expression.text === 'require' &&
    typescript_1.default.isStringLiteral(node.arguments[0]) &&
    node.arguments.length === 1;
const isDynamicImport = (node) => typescript_1.default.isCallExpression(node) && node.expression.kind === typescript_1.default.SyntaxKind.ImportKeyword;
const importExportVisitor = (ctx, sf, opts = { projectBaseDir: '' }, regexps) => {
    const visitor = (node) => {
        let importPath = '';
        if ((typescript_1.default.isImportDeclaration(node) || typescript_1.default.isExportDeclaration(node)) && node.moduleSpecifier) {
            const importPathWithQuotes = node.moduleSpecifier.getText(sf);
            importPath = importPathWithQuotes.substr(1, importPathWithQuotes.length - 2);
        }
        else if (isDynamicImport(node) || isRequire(node)) {
            const importPathWithQuotes = node.arguments[0].getText(sf);
            importPath = importPathWithQuotes.substr(1, importPathWithQuotes.length - 2);
        }
        else if (typescript_1.default.isImportTypeNode(node) &&
            typescript_1.default.isLiteralTypeNode(node.argument) &&
            typescript_1.default.isStringLiteral(node.argument.literal)) {
            importPath = node.argument.literal.text; // `.text` instead of `getText` bc this node doesn't map to sf (it's generated d.ts)
        }
        if (importPath) {
            const rewrittenPath = rewritePath(importPath, sf, opts, regexps, node.parent.locals ? node.parent.locals.keys().next().value : null);
            // Only rewrite relative path
            if (rewrittenPath !== importPath) {
                if (typescript_1.default.isImportDeclaration(node)) {
                    // @ts-ignore
                    return ctx.factory.updateImportDeclaration(node, node.decorators, node.modifiers, node.importClause, ctx.factory.createStringLiteral(rewrittenPath));
                }
                else if (typescript_1.default.isExportDeclaration(node)) {
                    // @ts-ignore
                    return ctx.factory.updateExportDeclaration(node, node.decorators, node.modifiers, node.isTypeOnly, node.exportClause, ctx.factory.createStringLiteral(rewrittenPath));
                }
                else if (isDynamicImport(node) || isRequire(node)) {
                    return ctx.factory.updateCallExpression(node, node.expression, node.typeArguments, ctx.factory.createNodeArray([ctx.factory.createStringLiteral(rewrittenPath)]));
                }
                else if (typescript_1.default.isImportTypeNode(node)) {
                    return ctx.factory.updateImportTypeNode(node, ctx.factory.createLiteralTypeNode(ctx.factory.createStringLiteral(rewrittenPath)), node.qualifier, node.typeArguments, node.isTypeOf);
                }
            }
            return node;
        }
        return typescript_1.default.visitEachChild(node, visitor, ctx);
    };
    return visitor;
};
const transformImportPaths = (opts) => {
    const { alias = {} } = opts;
    const regexps = Object.keys(alias).reduce((all, regexString) => {
        all[regexString] = new RegExp(regexString, 'gi');
        return all;
    }, {});
    return (ctx) => {
        return (sf) => typescript_1.default.visitNode(sf, importExportVisitor(ctx, sf, opts, regexps));
    };
};
exports.transformImportPaths = transformImportPaths;
