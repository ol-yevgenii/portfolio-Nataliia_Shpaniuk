"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const vm = require('vm');
// === IMPORTS NEEDED FOR RUNTIME EVALUATION ===
// need to import the tsx() transform code for later evaluation
require("./tsx");
// SSG runtime
require("./runtime");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const folders_1 = require("../io/folders");
const routing_1 = require("./routing");
const runtime_1 = require("./runtime");
const context_1 = require("./context");
const bundle_1 = require("./bundle");
const run = async (scriptCode, context) => {
    var _a, _b, _c;
    let state;
    // Vanil execution context
    const VanilLocal = {
        mode: context.mode,
        restartOnFileChange: (path) => globalThis.restartOnFileChange(path, context),
        // export methods publicly available
        fetch: cross_fetch_1.default,
        fetchContent: (path) => globalThis.vanilFetchContent(path, context),
        resolve: (path) => globalThis.resolvePathRelative(path, context.path),
        setPropsState: (_state) => {
            // map result state
            state = _state;
        },
        // Vanil.props (dynamically set here and extended in generated runtime code)
        props: {
            context,
            state: {},
            // from dynamic routing props
            ...(((_a = context.pageParamsAndProps) === null || _a === void 0 ? void 0 : _a.props) || {}),
        },
        // Vanil.request (dynamically set, passing path based routing params)
        request: {
            url: (0, routing_1.getPageUrl)(context.materializedPath, context),
            // from dynamic routing path params
            params: ((_b = context.pageParamsAndProps) === null || _b === void 0 ? void 0 : _b.params) || {},
        },
        // Vanil.slots (dynamically used when importing .astro components for passing children)
        slots: {},
        // Vanil.site
        site: context.config.buildOptions.site,
        isPage: context.path.indexOf((0, folders_1.getPagesFolder)(context.config)) > -1 ? true : false,
    };
    let data;
    try {
        const script = new vm.Script(`${scriptCode};exports.default ? exports.default({}) : exports`);
        const runContext = new vm.createContext({
            globalThis: globalThis,
            exports: {},
            process: process,
            console: console,
            require: require,
            context: context,
            React: {},
            importVanilComponent: (props) => (0, runtime_1.preprocessVanilComponentPropsAndSlots)(props, VanilLocal),
            // Vanil.fetchContent() and Vanil.resolve() with path-relative support
            Vanil: {
                ...Vanil,
                ...VanilLocal,
            },
            // general TSX/JSX processing function with hoisting support
            tsx: (type, attributes, ...children) => globalThis._tsx(type, attributes, context, VanilLocal, ...children),
        });
        // const dt = Date.now()
        data = await script.runInContext(runContext, {
            lineOffset: 0,
            displayErrors: true,
        });
        // accumulate detected interactive runtime feature use
        (0, context_1.addFeatureFlags)((0, bundle_1.detectRuntimeLibraryFeatures)(data, context.mode), context);
        // console.log('vm elapsed', context.path, Date.now() - dt)
    }
    catch (e) {
        const errorStackTraceSplits = (_c = e.stack) === null || _c === void 0 ? void 0 : _c.split('\n');
        const linesOfError = [errorStackTraceSplits[1], errorStackTraceSplits[2]];
        const errorTrace = {
            error: {
                original: e,
                errorType: e.name,
                errorMessage: e.message.split('\n')[0],
                linesOfError,
            },
        };
        return errorTrace;
    }
    return {
        data,
        state,
    };
};
exports.run = run;
