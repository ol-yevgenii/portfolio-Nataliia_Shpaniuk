"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectInteractiveRuntimeLibrary = exports.bundleRuntimeState = exports.bundleRequires = exports.detectRuntimeLibraryFeatures = exports.extractAllScriptCodeFromVdom = exports.bundleInteractiveRuntimeLibrary = exports.requiresInteractiveRuntimeLibrary = exports.getInteractiveRuntimeVariantName = exports.featureFlagsArray = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const dev_1 = require("../../cli/dev");
const file_1 = require("../io/file");
const folders_1 = require("../io/folders");
const map_1 = require("../io/map");
const context_1 = require("./context");
const dom_1 = require("./dom");
const parse_1 = require("./parse");
const persist_1 = require("./persist");
const resolve_1 = require("./resolve");
const transform_1 = require("./transform");
const transpile_1 = require("./transpile");
/** returns the feature flags as an array of names */
const featureFlagsArray = (featureFlags) => Object.keys(featureFlags).filter((moduleName) => featureFlags[moduleName]);
exports.featureFlagsArray = featureFlagsArray;
/** generates a distinct name for a interactive runtime library variant */
const getInteractiveRuntimeVariantName = (featureFlags) => `${(0, exports.featureFlagsArray)(featureFlags)
    .map((featureFlagName) => featureFlagName[0])
    .join('')}`;
exports.getInteractiveRuntimeVariantName = getInteractiveRuntimeVariantName;
/** verifies if the runtime lib needs to be injected by checking if at least one of the flags are active */
const requiresInteractiveRuntimeLibrary = (featureFlags) => (0, map_1.oneOf)(featureFlags, (flags, flagName) => flags[flagName]);
exports.requiresInteractiveRuntimeLibrary = requiresInteractiveRuntimeLibrary;
/** loads all parts of the interactive runtime library, concats them  */
const bundleInteractiveRuntimeLibrary = (context, featureFlags) => {
    let runtimeCode = (0, exports.requiresInteractiveRuntimeLibrary)(featureFlags)
        ? '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/init.ts')) + '\n' + `Vanil.mode = '${context.mode}'`
        : '';
    if (featureFlags.tsx) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/tsx.ts'));
    }
    if (featureFlags.vdom) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/vdom.ts'));
    }
    if (featureFlags.query) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/query.ts'));
    }
    if (featureFlags.events) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/events.ts'));
    }
    if (featureFlags.warnOnSsgApiUse) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/warnOnSsgApiUse.ts'));
    }
    if (featureFlags.livereload) {
        runtimeCode += `\n__VANIL_LIVE_RELOAD_URL = "${(0, dev_1.getLiveReloadUrl)(context.config)}";\n`;
        runtimeCode += (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/livereload.ts'));
    }
    if (featureFlags.store) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/store.ts'));
    }
    if (featureFlags.bus) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/bus.ts'));
    }
    if (featureFlags.i18n) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/i18n.ts'));
    }
    // --- built-in components (interactive runtime)
    // Code ande Debug depend on Link
    if (featureFlags.Code || featureFlags.Debug || featureFlags.Link) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/components/Link.tsx'));
    }
    // Code ande Debug depend on Script
    if (featureFlags.Code || featureFlags.Debug || featureFlags.Script) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/components/Script.tsx'));
    }
    // Debug depends on Code
    if (featureFlags.Code || featureFlags.Debug) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/components/Code.tsx'));
    }
    if (featureFlags.Debug) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/components/Debug.tsx'));
    }
    if (featureFlags.Trans) {
        runtimeCode += '\n' + (0, file_1.readFileSyncUtf8)((0, path_1.resolve)(__dirname, '../runtime/components/Trans.tsx'));
    }
    if (featureFlags.Markdown) {
        runtimeCode += '\n Vanil.Markdown = () => "Error: Markdown> is not supported at runtime in browser."';
    }
    if (!runtimeCode)
        return '';
    // warp in async iife to enclose from polluting global scope
    return (0, transform_1.mayWrapInAsyncIIFE)((0, transpile_1.transpileRuntimeInteractiveScriptCode)(`${runtimeCode};`, false, context.path, 'hoist', context), true);
};
exports.bundleInteractiveRuntimeLibrary = bundleInteractiveRuntimeLibrary;
const extractAllScriptCodeFromVdom = (node) => {
    let code = '';
    const walk = (currentNode) => {
        if (!currentNode)
            return;
        if (currentNode.type === 'script') {
            code += currentNode.children[0];
            return;
        }
        else if (currentNode.children) {
            for (let i = 0; i < currentNode.children.length; i++) {
                walk(currentNode.children[i]);
            }
        }
    };
    walk(node);
    return code;
};
exports.extractAllScriptCodeFromVdom = extractAllScriptCodeFromVdom;
/** runtime library feature detector based on actual generated code */
const detectRuntimeLibraryFeatures = (node, mode) => {
    const isInDevMode = mode === 'development';
    const code = (0, exports.extractAllScriptCodeFromVdom)(node);
    const baseFeatureFlagsMap = {
        events: /\{[\s\S]*?on[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code) || // all variants of { on } = Vanil usage
            /Vanil\.e\(/.test(code),
        query: /\$[\s]*?\(/.test(code) || // all variants of $('#query')
            /\{[\s\S]*?refs[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        tsx: /Vanil\.tsx\(/.test(code) || // generated result of <tsx> syntax usage (fn)
            /\{[\s\S]*?tsx[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        vdom: /\{[\s\S]*?render[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        store: /\{[\s\S]*?set[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code) || // all variants of { set } = Vanil usage
            /\{[\s\S]*?get[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        bus: /\{[\s\S]*?listen[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code) || // all variants of { listen } = Vanil usage
            /\{[\s\S]*?emit[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        i18n: /\{[\s\S]*?t[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code) || // all variants of { t } = Vanil usage
            /\{[\s\S]*?changeLanguage[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code) || // all variants of { changeLanguage } = Vanil usage
            /\{[\s\S]*?setTranslations[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        // components runtime support
        Code: /Vanil.tsx\(Code/.test(code) || /\{[\s\S]*?Code[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        Debug: /Vanil.tsx\(Debug/.test(code) || /\{[\s\S]*?Debug[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        Script: /Vanil.tsx\(Script/.test(code) || /\{[\s\S]*?Script[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        Link: /Vanil.tsx\(Link/.test(code) || /\{[\s\S]*?Link[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        Trans: /Vanil.tsx\(Trans/.test(code) || /\{[\s\S]*?Trans[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        Markdown: /Vanil.tsx\(Markdown/.test(code) || /\{[\s\S]*?Markdown[\s\S]*?\}[\s]*?=[\s]*?Vanil/.test(code),
        // always add HMR support in dev mode
        livereload: isInDevMode,
        // when SSG runtime API is used in browser/interactive, add warnings as exceptions in dev
        warnOnSsgApiUse: isInDevMode && (/fetchContent[\s]*?\(/.test(code) || /resolve[\s]*?\(/.test(code)),
    };
    return baseFeatureFlagsMap;
};
exports.detectRuntimeLibraryFeatures = detectRuntimeLibraryFeatures;
/** processes all require(...) statements and inflates, transpiles, bundles its code recursively */
const bundleRequires = (code, path = '.', context) => {
    const resultCode = (0, parse_1.processRequireFunctionCalls)(code, (importPath) => {
        if (importPath === 'vanil') {
            return `Vanil`;
        }
        const nodeResolvedPath = (0, resolve_1.resolveNodeAbsolute)(importPath, context.path);
        // like http://... or //foo or /foo.ts
        // (in terms of fetch from HTTP endpoint because the file doesn't exist on disk)
        if ((0, resolve_1.isRemoteImportTarget)(importPath)) {
            return `await import("${importPath}")`;
        }
        else {
            // like /foo/bar.ts
            if ((0, resolve_1.isAbsoluteFileImportTarget)(importPath)) {
                importPath = (0, resolve_1.materializePathSelectFile)(importPath);
            }
            else if (nodeResolvedPath) {
                const relativeDistModuleImportPath = (0, resolve_1.resolveNodeAbsolute)(importPath, context.path).split('node_modules')[1];
                const moduleBaseName = importPath.split('/')[0];
                const absoluteImportPath = (0, path_1.join)((0, folders_1.getDistFolder)(context.config), 'node_modules', relativeDistModuleImportPath);
                if (!(0, fs_1.existsSync)(absoluteImportPath)) {
                    (0, folders_1.copyModuleToDistAndBundleForBrowser)(context, moduleBaseName, absoluteImportPath);
                }
                return `eval(\`module={};(() => {\${await (await fetch("/node_modules${relativeDistModuleImportPath}.bundle.js")).text()}})();module.exports\`)`;
            }
            else if (isRelativeSrcTarget(importPath)) {
                // like ../foo or ./foo
                importPath = (0, resolve_1.resolveImportForRuntimeInteractiveCode)(importPath, path);
                if (!(0, fs_1.existsSync)(importPath)) {
                    // try resolving with file extension
                    importPath = (0, path_1.resolve)(path, `${importPath}.js`);
                }
            }
            else {
                return `((() => { throw new Error("Error: '${importPath}' cannot be imported!")})())`;
            }
        }
        if (importPath.startsWith('..')) {
            importPath = (0, path_1.resolve)(process.cwd(), importPath);
        }
        // add dependencies for change detection
        (0, context_1.addFileDependency)(importPath, context);
        // using loadAndTranspileCode we run this process recursively (ergo: general purpose bundle processing)
        // returning the exports at the end of the iife allows ideomatic direct code injection
        return (0, transform_1.wrapInIIFE)(`${(0, transpile_1.loadAndTranspileCode)(importPath, 'js', 'tsx', 'import', context)}`);
    });
    return (resultCode
        // enable await in wrapping Promise.resolve
        .replace(/Promise.resolve\(\)\.then\(\(\) =>/, 'Promise.resolve().then(async() =>')
        // bundle replace left-overs
        .replace(/const ;/g, '')
        .replace(/let ;/g, '')
        .replace(/var ;/g, ''));
};
exports.bundleRequires = bundleRequires;
/** stringifies the state to be accessible via Vanil.state  */
const bundleRuntimeState = (runtimeState, context) => {
    if (!runtimeState &&
        !context.runtimeLibraryFeatureFlags.query &&
        !Object.keys(context.refs).length &&
        !context.runtimeLibraryFeatureFlags.i18n)
        return '';
    // TODO: perf: potential opportunity for caching
    const runtimeStateCode = (0, transpile_1.transpileTSX)(`

        // initialize Vanil.props with runtimeState
        Vanil.props = { state: ${JSON.stringify(runtimeState, null, 2)} }

        // set language used at SSG time by default at runtime
        ${context.runtimeLibraryFeatureFlags.i18n
        ? `
        Vanil.language = "${globalThis.Vanil.language}"
        Vanil.translations = ${JSON.stringify(globalThis.Vanil.translations, null, 2)}
        `
        : ''}

        ${Object.keys(context.refs).length
        ? `
            // backing data object for refs
            Vanil._refs = ${JSON.stringify(context.refs, null, 2)}

            // proxy refs to make sure we'll always return $-wrapped elements
            Vanil.refs = new Proxy(Vanil._refs, {
                get: function(target, prop, receiver) {
                  const el = Reflect.get(...arguments)
                    return typeof el === 'string' ? document.querySelector(el) : el
                }
            });`
        : ''}
    `, context, 'hoist');
    return runtimeStateCode;
};
exports.bundleRuntimeState = bundleRuntimeState;
/** hoists the interactive Vanil runtime */
const injectInteractiveRuntimeLibrary = (document, headElement, context, runtimeState) => {
    if (document && headElement) {
        const runtimeStateCode = (0, exports.bundleRuntimeState)(runtimeState, context);
        if (runtimeStateCode) {
            // hoist; available for interactive runtime as Vanil.state
            (0, dom_1.injectVirtualDomElement)(headElement, (0, dom_1.createVirtualDomScriptElement)(document, runtimeStateCode, {
                role: 'state',
            }));
        }
        const featureFlags = {
            ...context.runtimeLibraryFeatureFlags,
            // determine if runtimeState is given;
            // in this case, initialization code must be added
            runtimeState: !!runtimeStateCode,
        };
        const runtimeVariantName = (0, exports.getInteractiveRuntimeVariantName)(featureFlags);
        const distDirPath = (0, folders_1.getDistFolder)(context.config);
        const runtimeVariantDistPath = (0, path_1.resolve)(distDirPath, 'runtime', `${runtimeVariantName}.js`);
        const isVariantCached = (0, fs_1.existsSync)(runtimeVariantDistPath);
        const interactiveRuntimeCode = isVariantCached
            ? (0, file_1.readFileSyncUtf8)(runtimeVariantDistPath)
            : // generate a new dynamic interactive runtime lib variant, not cached yet
                (0, exports.bundleInteractiveRuntimeLibrary)(context, featureFlags);
        if (!isVariantCached && interactiveRuntimeCode) {
            // ensure it's written to cache
            (0, persist_1.persistFileAbsolute)(runtimeVariantDistPath, interactiveRuntimeCode);
        }
        // reference interactive runtime lib in development
        if (context.mode === 'development') {
            (0, dom_1.injectVirtualDomElement)(headElement, (0, dom_1.createVirtualDomScriptElement)(document, '', {
                // reference the lib relatively to the dist folder
                src: runtimeVariantDistPath.replace(distDirPath, ''),
                role: 'runtime',
            }));
        }
        else if (context.mode === 'production') {
            // hoist interactive runtime lib in production
            if (interactiveRuntimeCode) {
                // bundle in Vanil runtime library (unstash, prepend)
                (0, dom_1.injectVirtualDomElement)(headElement, (0, dom_1.createVirtualDomScriptElement)(document, interactiveRuntimeCode, {
                    role: 'runtime',
                }));
            }
        }
    }
};
exports.injectInteractiveRuntimeLibrary = injectInteractiveRuntimeLibrary;
