"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRelativeSrcTarget = exports.isRemoteImportTarget = exports.isAbsoluteFileImportTarget = exports.materializePathSelectFile = exports.resolveNodeImport = exports.resolveNodeAbsolute = exports.resolveImportForRuntimeInteractiveCode = exports.isRelativePathImport = exports.isDir = exports.resolvePathRelative = void 0;
const path_1 = require("path");
const fast_glob_1 = __importDefault(require("fast-glob"));
const context_1 = require("./context");
const fs_1 = require("fs");
const nodeResolve = require('node-resolve');
/**
 * import(path), import ... from path, Vanil.fetchContent(path)
 * relative import resolve logic (e.g. ../components or )
 */
const resolvePathRelative = (targetPath, path) => (0, path_1.resolve)((0, exports.isDir)(path) ? path : (0, path_1.dirname)(path), targetPath);
exports.resolvePathRelative = resolvePathRelative;
const isDir = (path) => (0, fs_1.existsSync)(path) && (0, fs_1.lstatSync)(path).isDirectory();
exports.isDir = isDir;
/** decides if a path is a relative import (relative to a path) */
const isRelativePathImport = (path) => path.startsWith('../') || path.startsWith('./');
exports.isRelativePathImport = isRelativePathImport;
/** returns an absolute import path or a :// protocol import path based on a relative import */
const resolveImportForRuntimeInteractiveCode = (importPath, path = '.') => {
    if ((0, exports.isRelativePathImport)(importPath)) {
        return (0, exports.resolvePathRelative)(importPath, path);
    }
    else {
        return importPath;
    }
};
exports.resolveImportForRuntimeInteractiveCode = resolveImportForRuntimeInteractiveCode;
/** uses the node resolve algorithm to discover and rewrite paths to absolute paths */
const resolveNodeAbsolute = (importPath, relImportPath) => {
    const resolvedPath = nodeResolve.resolve(relImportPath, importPath, (0, exports.isDir)(relImportPath) ? relImportPath : (0, path_1.dirname)(relImportPath));
    if (resolvedPath) {
        return resolvedPath;
    }
    return resolvedPath;
};
exports.resolveNodeAbsolute = resolveNodeAbsolute;
/** resolves a Node.js module imports (for SSG Node.js top level code) */
const resolveNodeImport = (importPath, context, relImportPath) => {
    const path = relImportPath ? relImportPath : context.path;
    const moduleResolved = (0, exports.resolveNodeAbsolute)(importPath, (0, exports.isDir)(path) ? path : (0, path_1.dirname)(path));
    if (moduleResolved) {
        return (0, path_1.resolve)(relImportPath ? relImportPath : (0, path_1.dirname)(context.path), moduleResolved);
    }
    // we can't support "localFile.*" cases, because these
    // cannot be separated from Node.js node_module imports
    let resolvedImportPath = (0, exports.resolveImportForRuntimeInteractiveCode)(importPath);
    // use .astro component-relative import path resolving
    if (context.isProcessingComponent) {
        resolvedImportPath = (0, exports.resolveImportForRuntimeInteractiveCode)(importPath, context.path);
    }
    // import of a relative/absolute module, maybe inside of .astro component
    if (relImportPath) {
        resolvedImportPath = (0, exports.resolveImportForRuntimeInteractiveCode)(importPath, relImportPath);
    }
    // register in dependency linked list
    (0, context_1.addFileDependency)(resolvedImportPath, context);
    return resolvedImportPath;
};
exports.resolveNodeImport = resolveNodeImport;
/** materializes a module import selecting a file by extension, priority */
const materializePathSelectFile = (path) => fast_glob_1.default.sync(`${path}*.{tsx,jsx,ts,js}`)[0];
exports.materializePathSelectFile = materializePathSelectFile;
/** decides if the file is a (valid) absolute source file path import (file exists and extension supported) */
const isAbsoluteFileImportTarget = (path) => !!(0, exports.materializePathSelectFile)(path);
exports.isAbsoluteFileImportTarget = isAbsoluteFileImportTarget;
/** decides if an import/require target path looks like //foo/bar or https://, etc. */
const isRemoteImportTarget = (path) => path.indexOf('//') > -1 && !(0, exports.isAbsoluteFileImportTarget)(path);
exports.isRemoteImportTarget = isRemoteImportTarget;
/**
 * used for processing inside of tsx() where {} TSX expressions can happen
 * in <* href={} and <* src={} scanarios
 */
const isRelativeSrcTarget = (srcTarget) => {
    if (!srcTarget) {
        return false;
    }
    let isRelative = true;
    // remote source without protocol
    if (srcTarget.startsWith('/') && !srcTarget.startsWith('//'))
        isRelative = false;
    // remore source with protocol
    if (srcTarget.indexOf('://') > -1)
        isRelative = false;
    // dyanmic TSX evaluation
    if (srcTarget.trim()[0] === '{' && srcTarget.trim()[srcTarget.length - 1] === '}')
        isRelative = false;
    return isRelative;
};
exports.isRelativeSrcTarget = isRelativeSrcTarget;
