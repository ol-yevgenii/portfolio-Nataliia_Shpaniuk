"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPageUrl = exports.getPathUri = exports.materializeDynamicRoutingPaths = exports.paginate = exports.parseForGetStaticPathsFn = exports.parseDynamicRoutingPath = exports.RE_PARAM_WRAPPERS = void 0;
const path_1 = require("path");
const array_1 = require("../io/array");
const folders_1 = require("../io/folders");
const parse_1 = require("./parse");
const transpile_1 = require("./transpile");
const vm_1 = require("./vm");
exports.RE_PARAM_WRAPPERS = /[\[\]]/g;
const parseDynamicRoutingPath = (context) => {
    const relativePath = (0, folders_1.toProjectRootRelativePath)(context.path, context.config);
    const pathSplits = relativePath.split('/');
    const params = {};
    pathSplits.forEach((pathSplit) => {
        if ((0, folders_1.isDynamicRoutingPath)(pathSplit)) {
            const paramName = pathSplit.split(']')[0].replace(exports.RE_PARAM_WRAPPERS, '');
            if (paramName.startsWith('...')) {
                params[paramName] = 'rest';
            }
            else {
                params[paramName] = 'named';
            }
        }
    });
    return params;
};
exports.parseDynamicRoutingPath = parseDynamicRoutingPath;
/** implements parsing for getStaticPaths() function declarations and extracts the code */
const parseForGetStaticPathsFn = async (wholeSsgCode) => new Promise((resolve) => {
    (0, parse_1.processGSPFunctionDeclaration)(wholeSsgCode, (fnCode) => {
        resolve(fnCode);
    });
});
exports.parseForGetStaticPathsFn = parseForGetStaticPathsFn;
/**
 * chunks the data in slices of paginationParams.pageSize and
 * generates a page prop to be passed to each page */
const paginate = (data, paginationParams) => {
    // mid-term goal:
    // TODO: implement pagination with typical page objects just as described in
    //       https://docs.astro.build/reference/api-reference/#getstaticpaths paginate()
    console.log((0, array_1.chunk)(2, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));
    return data;
};
exports.paginate = paginate;
/**
 * parses the given .astro page files path for dynamic routing parts
 * (e.g. [foo] or [...foo]), isolates the getStaticPaths function and
 * generates a list of materialized paths that represent all possible
 * permutations; returns these, together with the corresponding props
 */
const materializeDynamicRoutingPaths = async (context) => {
    var _a;
    const parsedParams = (0, exports.parseDynamicRoutingPath)(context);
    const paramNames = Object.keys(parsedParams);
    const codeBundle = (0, parse_1.parseTemplate)(context.path, context);
    let isolatedGetStaticPathsFnCode = await (0, exports.parseForGetStaticPathsFn)(codeBundle.typeScriptCode);
    context.isolatedGetStaticPathsFnCode = isolatedGetStaticPathsFnCode;
    if (!isolatedGetStaticPathsFnCode) {
        // throwing meaningful errors is important;
        // how can newbies know what to do? Let's give them a good hint
        throw new Error(`The following path is dynamic: ${(0, folders_1.toProjectRootRelativePath)(context.path, context.config)}, but no export async getStaticPaths() function could be found in ${(0, path_1.basename)(context.path)}! 
        
        Please implement it e.g. like this:

        // in ${(0, path_1.basename)(context.path)}, first section for SSG code:
        export const getStaticPaths = async() => {

            // your code to fetch / load data necessary to determine all 
            // possible page variants/permutations goes here

            return [{
                ${Object.keys(parsedParams)[0]}: "someData",
                ...
            }, ...]
        }
        `);
    }
    // transform into an iife; yielding the result
    // TODO: mid-term goal: inject rss() as well
    isolatedGetStaticPathsFnCode = `

    ${(0, parse_1.parseImportStatements)(codeBundle.typeScriptCode)
        .filter((importStmt) => !importStmt.includes('.astro'))
        .join('\n')}
  
    export default (() => (${isolatedGetStaticPathsFnCode})({ 
        paginate: globalThis.paginate 
    })})`;
    const currentCwd = process.cwd();
    process.chdir((0, path_1.dirname)(context.path));
    const transpiledCode = (await (0, transpile_1.transpileSSGCode)(isolatedGetStaticPathsFnCode, context)).replace(transpile_1.TS_IMPORT_POLYFILL_SCRIPT, '');
    const result = await (0, vm_1.run)(transpiledCode, context);
    process.chdir(currentCwd);
    const materializedPages = [];
    if (result.error) {
        throw result.error;
    }
    try {
        (_a = result.data) === null || _a === void 0 ? void 0 : _a.forEach((pageParamsAndProps, index) => {
            let materializedPath = context.path;
            paramNames.forEach((paramName) => {
                const paramType = parsedParams[paramName];
                const paramValue = pageParamsAndProps.params[paramName];
                if (!paramValue) {
                    throw new Error(`getStaticPaths() returned the following params: ${JSON.stringify(pageParamsAndProps.params, null, 2)} for data index ${index}, but param [${paramName}] is missing!`);
                }
                materializedPath = materializedPath.replace(paramType === 'named' ? `[${paramName}]` : `[...${paramName}]`, paramType === 'rest' && paramValue == '1' ? '' : paramValue);
            });
            materializedPages.push({
                materializedPath,
                pageParamsAndProps,
            });
        });
    }
    catch (e) {
        throw new Error(`getStaticPaths() should return an Array of PageParamsAndProps objects, just like this: [
            { params: { ${Object.keys(parsedParams)[0]}: "someData", ... }, props: { /* optional */ ... } },
            ...
        ]`);
    }
    return materializedPages;
};
exports.materializeDynamicRoutingPaths = materializeDynamicRoutingPaths;
/** generates the path URI relative to the dist folder and depending on the URI format */
const getPathUri = (materializedPath, context) => {
    var _a;
    // uses (pre-)materialized path in case of dynamic routing (see routing.ts),
    // else the static template path to the .astro file
    const path = materializedPath ? materializedPath : context.path;
    // removes absolute path till pages folder
    let relativePath = path.replace((0, folders_1.getPagesFolder)(context.config), '');
    // /index or /index.html should just fallback to the root URL
    if (relativePath === '/index' || relativePath === '/index.html') {
        relativePath = '';
    }
    // removes .astro
    const relativePathNoFileExt = relativePath.split('.')[0];
    // encode each part of the path for use as URI
    let relativePathUriEncoded = relativePathNoFileExt
        .split('/')
        .map((pathPartName) => encodeURIComponent(pathPartName))
        .join('/');
    // append .html based on format
    if (((_a = context.config.buildOptions) === null || _a === void 0 ? void 0 : _a.pageUrlFormat) === 'file') {
        relativePathUriEncoded += '.html';
    }
    return relativePathUriEncoded;
};
exports.getPathUri = getPathUri;
/** generates the effective page URL based on the site and materialized path */
const getPageUrl = (materializedPath, context) => { var _a; return `${(_a = context.config.buildOptions) === null || _a === void 0 ? void 0 : _a.site}${(0, exports.getPathUri)(materializedPath, context)}`; };
exports.getPageUrl = getPageUrl;
