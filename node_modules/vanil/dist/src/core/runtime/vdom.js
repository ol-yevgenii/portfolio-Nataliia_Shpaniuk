"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAbstractDOM = void 0;
// BEWARE: ISOMORPHIC IMPLEMENTATION :: ALSO USED IN SSG TRANSFORM STEP
const CLASS_ATTRIBUTE_NAME = 'class';
const XLINK_ATTRIBUTE_NAME = 'xlink';
const REF_ATTRIBUTE_NAME = 'ref';
const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
const getAbstractDOM = (document, context) => {
    // DOM abstraction layer for manipulation
    const AbstractDOM = {
        hasElNamespace: (domElement) => domElement.namespaceURI === SVG_NAMESPACE,
        hasSvgNamespace: (parentElement, type) => AbstractDOM.hasElNamespace(parentElement) && type !== 'STYLE' && type !== 'SCRIPT',
        createElementOrElements: (virtualNode, parentDomElement) => {
            if (Array.isArray(virtualNode)) {
                return AbstractDOM.createChildElements(virtualNode, parentDomElement);
            }
            if (typeof virtualNode !== 'undefined') {
                return AbstractDOM.createElement(virtualNode, parentDomElement);
            }
            // undefined virtualNode -> e.g. when a tsx variable is used in markup which is undefined
            return AbstractDOM.createTextNode('', parentDomElement);
        },
        createElement: (virtualNode, parentDomElement) => {
            let newEl;
            if (virtualNode.type.toUpperCase() === 'SVG' ||
                (parentDomElement && AbstractDOM.hasSvgNamespace(parentDomElement, virtualNode.type.toUpperCase()))) {
                newEl = document.createElementNS(SVG_NAMESPACE, virtualNode.type, {});
            }
            else {
                newEl = document.createElement(virtualNode.type);
            }
            // istanbul ignore else
            if (virtualNode.attributes) {
                AbstractDOM.setAttributes(virtualNode.attributes, newEl);
            }
            // istanbul ignore else
            if (virtualNode.children) {
                AbstractDOM.createChildElements(virtualNode.children, newEl);
            }
            // istanbul ignore else
            if (parentDomElement) {
                parentDomElement.appendChild(newEl);
            }
            return newEl;
        },
        createTextNode: (text, domElement) => {
            const node = document.createTextNode(text.toString());
            // istanbul ignore else
            if (domElement) {
                domElement.appendChild(node);
            }
            return node;
        },
        createChildElements: (virtualChildren, domElement) => {
            const children = [];
            for (let i = 0; i < virtualChildren.length; i++) {
                const virtualChild = virtualChildren[i];
                if (virtualChild === null || (typeof virtualChild !== 'object' && typeof virtualChild !== 'function')) {
                    children.push(AbstractDOM.createTextNode((typeof virtualChild === 'undefined' || virtualChild === null ? '' : virtualChild).toString(), domElement));
                }
                else {
                    children.push(AbstractDOM.createElement(virtualChild, domElement));
                }
            }
            return children;
        },
        setAttribute: (name, value, domElement) => {
            // attributes not set (undefined) are ignored; use null value to reset an attributes state
            if (typeof value === 'undefined')
                return;
            // to reference elements by name and map the to Vanil.refs['$refName']
            if (name === REF_ATTRIBUTE_NAME && typeof value !== 'function') {
                if (typeof window === 'undefined') {
                    // SSG generates the DOM selector query, runtime assigns reference
                    context.refs[value] = `${domElement.tagName}[${REF_ATTRIBUTE_NAME}=${value}]`;
                }
                else {
                    Vanil.refs[value] = domElement;
                }
            }
            // support simple innerHTML set via attribute
            if (name === 'innerHTML') {
                domElement.innerHTML = value;
                return;
            }
            // support React variant for setting innerHTML
            if (name === 'dangerouslySetInnerHTML') {
                domElement.innerHTML = value.__html;
                return;
            }
            // support React htmlFor/for
            if (name === 'htmlFor') {
                name = 'for';
            }
            // transforms className="..." -> class="..."
            // allows for React TSX to work seamlessly
            if (name === 'className') {
                name = CLASS_ATTRIBUTE_NAME;
            }
            // transforms class={['a', 'b']} into class="a b"
            if (name === CLASS_ATTRIBUTE_NAME && Array.isArray(value)) {
                value = value.join(' ');
            }
            if (AbstractDOM.hasElNamespace(domElement) && name.startsWith(XLINK_ATTRIBUTE_NAME)) {
                // allows for <svg><use xlinkHref ...></svg>
                domElement.setAttributeNS('http://www.w3.org/1999/xlink', `${XLINK_ATTRIBUTE_NAME}:${name.replace(XLINK_ATTRIBUTE_NAME, '')}`.toLowerCase(), value);
            }
            else if (name === 'style' && typeof value !== 'string') {
                const propNames = Object.keys(value);
                for (let i = 0; i < propNames.length; i++) {
                    ;
                    domElement.style[propNames[i]] = value[propNames[i]];
                }
            }
            else if (typeof value === 'boolean') {
                // for cases like <button checked={false} />
                ;
                domElement[name] = value;
            }
            else {
                // for any other case
                domElement.setAttribute(name, value);
            }
        },
        setAttributes: (attributes, domElement) => {
            const attrNames = Object.keys(attributes);
            for (let i = 0; i < attrNames.length; i++) {
                AbstractDOM.setAttribute(attrNames[i], attributes[attrNames[i]], domElement);
            }
        },
    };
    return function (virtualNode, parentDomElement) {
        if (typeof virtualNode === 'string') {
            return AbstractDOM.createTextNode(virtualNode, parentDomElement);
        }
        return AbstractDOM.createElementOrElements(virtualNode, parentDomElement);
    };
};
exports.getAbstractDOM = getAbstractDOM;
// browser runtime-interactive render function assignment
if (typeof Vanil !== 'undefined' && typeof document !== 'undefined') {
    Vanil.render = (0, exports.getAbstractDOM)(document, Vanil.props.context);
}
