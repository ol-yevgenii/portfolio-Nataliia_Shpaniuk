"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const VARIABLE_REGEX = /{([^}]*)}/g;
const I18N_DEFAULT_LANG = 'en';
Vanil.translations = Vanil.translations ? Vanil.translations : {};
Vanil.language = Vanil.language ? Vanil.language : I18N_DEFAULT_LANG;
Vanil.changeLanguage = (language) => {
    Vanil.language = language;
    if (Vanil.isBrowser) {
        window.dispatchEvent(new CustomEvent('languagechange', { detail: language }));
    }
    return Vanil.language;
};
const printOptions = (data) => JSON.stringify(data, null, 2);
const init = (namespace, key) => {
    const { language, translations } = Vanil;
    const namespaces = translations[language] || {};
    if (Vanil.mode === 'development' && typeof translations[language] === 'undefined') {
        console.warn(`(i18n) Missing language: { language: ${language} }`);
    }
    let pairs;
    if (typeof namespace === 'undefined') {
        pairs = translations[language];
    }
    else {
        pairs = namespaces[namespace] || {};
        if (Vanil.mode === 'development' && typeof namespaces[namespace] === 'undefined') {
            console.warn(`(i18n) Missing namespace: { language: '${language}', namespace: '${namespace}' }`);
        }
    }
    const translation = pairs[key] || key;
    if (Vanil.mode === 'development' && typeof pairs[key] === 'undefined') {
        console.warn(`(i18n) Missing key: { lang: '${language}', namespace: '${namespace}', key: '${key}' }`);
    }
    return { namespace, translation, language };
};
const translate = (ns, key, options = {}) => {
    const config = init(ns, key);
    let { translation } = config;
    const { language, namespace } = config;
    const consumedOptions = Object.assign({}, options);
    const optionKeys = translation.match(VARIABLE_REGEX) || [];
    for (let index = 0; index < optionKeys.length; index++) {
        const optionRawKey = optionKeys[index];
        // skip duplicates
        if (optionKeys.indexOf(optionRawKey) !== index)
            continue;
        const optionKey = optionRawKey.substr(1, optionRawKey.length - 2);
        const optionValue = consumedOptions[optionKey] || '';
        if (Vanil.mode === 'development' && typeof consumedOptions[optionKey] === 'undefined') {
            console.warn(`(i18n) Missing option: { language: '${language}', namespace: '${namespace}', key: '${key}', options: ${printOptions(optionKey)} }`);
        }
        delete consumedOptions[optionKey];
        // fast replace of all duplicates
        translation = translation.split(`{${optionKey}}`).join(optionValue);
    }
    // istanbul ignore else
    if (Vanil.mode === 'development') {
        const unusedOptions = Object.keys(consumedOptions);
        for (let index = 0; index < unusedOptions.length; index++) {
            console.info(`(i18n) Unknown option: { language: '${language}', namespace: '${namespace}', key: '${key}', options: ${printOptions(unusedOptions[index])} }`);
        }
    }
    return translation;
};
Vanil.t = (nsOrKey, options = {}) => {
    const type = typeof Vanil.translations[Vanil.language][nsOrKey];
    if (type === 'string') {
        // return translation w/o namespace
        return translate(undefined, nsOrKey, options);
    }
    else if (type === 'object') {
        // return a namespaced translation function
        return (key, options = {}) => translate(nsOrKey, key, options);
    }
    else {
        if (Vanil.mode === 'development') {
            console.warn(`(i18n) Missing translation: { language: '${Vanil.language}', key: '${nsOrKey}', options: ${printOptions(options)} }`);
        }
        // no translation available; fallback to input
        return nsOrKey;
    }
};
Vanil.tNs = (nsOrKey, options = {}) => Vanil.t(nsOrKey, options);
Vanil.setTranslations = (language, namespaceTranslation) => {
    Vanil.translations[language] = namespaceTranslation;
    return Vanil;
};
