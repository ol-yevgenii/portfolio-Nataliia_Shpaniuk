"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProject = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const inquirer = __importStar(require("inquirer"));
const colors = __importStar(require("kleur/colors"));
const printFooter_1 = require("./printFooter");
const child_process_1 = require("child_process");
const createProjectFolder_1 = require("./createProjectFolder");
const cloneRepository_1 = require("./cloneRepository");
const validateProjectDirectoryInput_1 = require("./validateProjectDirectoryInput");
const installModules_1 = require("./installModules");
const copyTemplate_1 = require("./copyTemplate");
/** creates a new project from a template named (default: examples/init), given a projectName */
const createProject = async (tplDir, destDir, projectName) => {
    if (!tplDir) {
        console.log(colors.yellow('[??] WARN: No template path/git repo specified. You can set it easily by adding --tpl $pathToTplOrGitRepo'));
        // fall-back to bundled "init" template
        tplDir = (0, path_1.resolve)(__dirname, '../../examples/init');
    }
    const isGitRepo = tplDir.startsWith('http');
    if (isGitRepo) {
        tplDir = await (0, cloneRepository_1.cloneRepository)(tplDir);
    }
    else if (!(0, fs_1.existsSync)(tplDir)) {
        console.log(colors.red(`[!!] Error: The template ${tplDir} doesn't exist. Exiting.`));
        process.exit(1);
    }
    if (!projectName) {
        // get project directory name
        const choiceProjectName = await inquirer.prompt([
            {
                type: 'input',
                name: 'projectName',
                default: 'MyVanilProject',
                message: `Please specify the project name (e.g. ${colors.cyan('MyVanilProject')}):`,
                validate: validateProjectDirectoryInput_1.validateProjectDirectoryInput,
            },
        ]);
        projectName = choiceProjectName.projectName;
    }
    const projectPathName = projectName.toLowerCase();
    const projectPath = (0, path_1.resolve)(destDir, projectPathName);
    const folderAlreadyExist = (0, fs_1.existsSync)(projectPath);
    if (folderAlreadyExist) {
        const shouldOverride = await inquirer.prompt([
            {
                type: 'confirm',
                default: false,
                name: 'answer',
                message: colors.yellow('[??] WARN: The chosen directory already exists. Do you want to override it?'),
            },
        ]);
        if (!shouldOverride.answer) {
            return false;
        }
    }
    if (!(0, createProjectFolder_1.createProjectFolder)(projectPath, projectPathName, folderAlreadyExist)) {
        return false;
    }
    const packageJSON = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(tplDir, 'package.json'), { encoding: 'utf8' }));
    const dependenciesAsString = transformPackageDependenciesToStrings(packageJSON, 'dependencies');
    const devDependenciesAsString = transformPackageDependenciesToStrings(packageJSON, 'devDependencies');
    if (!(0, copyTemplate_1.copyTemplate)(projectPath, tplDir, projectName)) {
        return false;
    }
    if (isGitRepo) {
        (0, child_process_1.execSync)(`rm -rf ${tplDir}`, {
            stdio: 'inherit',
        });
    }
    if (!(await (0, installModules_1.installModules)(projectPath, dependenciesAsString, devDependenciesAsString))) {
        return false;
    }
    const packageJson = JSON.parse((0, fs_1.readFileSync)((0, path_1.resolve)(__dirname, '../../package.json'), { encoding: 'utf8' }));
    (0, printFooter_1.printFooter)(packageJson.homepage, projectPath, packageJson.bugs.url);
};
exports.createProject = createProject;
const transformPackageDependenciesToStrings = (packageJson, key) => {
    const dependencies = [];
    for (const dependencyName in packageJson[key]) {
        dependencies.push(`${dependencyName}@${packageJson[key][dependencyName]}`);
    }
    return dependencies;
};
